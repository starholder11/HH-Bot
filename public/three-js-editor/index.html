<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js editor</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link rel="apple-touch-icon" href="images/icon.png">
		<link rel="manifest" href="manifest.json">
		<link rel="shortcut icon" href="/favicon.ico" />
	</head>
	<body>
		<link rel="stylesheet" href="css/main.css">

		<script type="importmap">
			{
				"imports": {
					"three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js",
					"three/addons/": "/examples/jsm/",
					"three/examples/": "/examples/",
					"three-gpu-pathtracer": "https://cdn.jsdelivr.net/npm/three-gpu-pathtracer@0.0.23/build/index.module.js",
					"three-mesh-bvh": "https://cdn.jsdelivr.net/npm/three-mesh-bvh@0.7.4/build/index.module.js"
				}
			}
		</script>

		<script src="/examples/jsm/libs/draco/gltf/draco_decoder.js"></script>

		<link rel="stylesheet" href="js/libs/codemirror/codemirror.css">
		<link rel="stylesheet" href="js/libs/codemirror/theme/monokai.css">
		<script src="js/libs/codemirror/codemirror.js"></script>
		<script src="js/libs/codemirror/mode/javascript.js"></script>
		<script src="js/libs/codemirror/mode/glsl.js"></script>

		<script src="js/libs/esprima.js"></script>
		<script src="js/libs/jsonlint.js"></script>

		<script src="https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.11.6/dist/ffmpeg.min.js"></script>

		<link rel="stylesheet" href="js/libs/codemirror/addon/dialog.css">
		<link rel="stylesheet" href="js/libs/codemirror/addon/show-hint.css">
		<link rel="stylesheet" href="js/libs/codemirror/addon/tern.css">

		<script src="js/libs/codemirror/addon/dialog.js"></script>
		<script src="js/libs/codemirror/addon/show-hint.js"></script>
		<script src="js/libs/codemirror/addon/tern.js"></script>
		<script src="js/libs/acorn/acorn.js"></script>
		<script src="js/libs/acorn/acorn_loose.js"></script>
		<script src="js/libs/acorn/walk.js"></script>
		<script src="js/libs/ternjs/polyfill.js"></script>
		<script src="js/libs/ternjs/signal.js"></script>
		<script src="js/libs/ternjs/tern.js"></script>
		<script src="js/libs/ternjs/def.js"></script>
		<script src="js/libs/ternjs/comment.js"></script>
		<script src="js/libs/ternjs/infer.js"></script>
		<script src="js/libs/ternjs/doc_comment.js"></script>
		<script src="js/libs/tern-threejs/threejs.js"></script>
		<script src="js/libs/signals.min.js"></script>

		<script type="module">

			import * as THREE from 'three';

			import { Editor } from './js/Editor.js';
			import { Viewport } from './js/Viewport.js';
			import { Toolbar } from './js/Toolbar.js';
			import { Script } from './js/Script.js';
			import { Player } from './js/Player.js';
			import { Sidebar } from './js/Sidebar.js';
			import { Menubar } from './js/Menubar.js';
			import { Resizer } from './js/Resizer.js';

			window.URL = window.URL || window.webkitURL;
			window.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;

			//

			const editor = new Editor();

			window.editor = editor; // Expose editor to Console
			window.THREE = THREE; // Expose THREE to APP Scripts and Console

			const viewport = new Viewport( editor );
			document.body.appendChild( viewport.dom );

			const toolbar = new Toolbar( editor );
			document.body.appendChild( toolbar.dom );

			const script = new Script( editor );
			document.body.appendChild( script.dom );

			const player = new Player( editor );
			document.body.appendChild( player.dom );

			const sidebar = new Sidebar( editor );
			document.body.appendChild( sidebar.dom );

			const menubar = new Menubar( editor );
			document.body.appendChild( menubar.dom );

			const resizer = new Resizer( editor );
			document.body.appendChild( resizer.dom );

			//

		// Add timeout and error handling for storage initialization
		let initTimeout = setTimeout(() => {
			console.error('Editor storage initialization timed out, proceeding anyway');
			initializeEditor();
		}, 5000);

		function initializeEditor() {
			clearTimeout(initTimeout);

			// Add sample scene objects immediately
			// Scene will be loaded from space data via postMessage

			// Clear any cached scene data
			editor.clear();

			console.log('Three.js Editor initialized successfully');
			try { window.parent.postMessage({ type: 'ready' }, '*'); } catch (e) {}
		}

		try {
			editor.storage.init( function () {
				clearTimeout(initTimeout);

				editor.storage.get( async function ( state ) {

					if ( isLoadingFromHash ) return;

					if ( state !== undefined ) {

						await editor.fromJSON( state );

					}

					const selected = editor.config.getKey( 'selected' );

					if ( selected !== undefined ) {

						editor.selectByUuid( selected );

					}

					initializeEditor();
				} );
			} );
		} catch (error) {
			console.error('Storage initialization failed:', error);
			initializeEditor();
		}

		//

		let timeout;

		function saveState() {

			if ( editor.config.getKey( 'autosave' ) === false ) {

				return;

			}

			clearTimeout( timeout );

			timeout = setTimeout( function () {

				editor.signals.savingStarted.dispatch();

				timeout = setTimeout( function () {

					editor.storage.set( editor.toJSON() );

					editor.signals.savingFinished.dispatch();

				}, 100 );

			}, 1000 );

		}

		const signals = editor.signals;

		signals.geometryChanged.add( saveState );
		signals.objectAdded.add( saveState );
		signals.objectChanged.add( saveState );
		signals.objectRemoved.add( saveState );
		signals.materialChanged.add( saveState );
		signals.sceneBackgroundChanged.add( saveState );
		signals.sceneEnvironmentChanged.add( saveState );
		signals.sceneFogChanged.add( saveState );
		signals.sceneGraphChanged.add( saveState );
		signals.scriptChanged.add( saveState );
		signals.historyChanged.add( saveState );

		// Bridge: forward updates to parent
		function send(msg) { try { window.parent.postMessage(msg, '*'); } catch (e) {} }
		signals.objectSelected.add(function(object){
			send({ type: 'selection_changed', data: { selectedObjects: object ? [object.uuid] : [] } });
		});
		signals.objectAdded.add(function(object){ send({ type: 'object_added', data: { uuid: object.uuid } }); });
		signals.objectRemoved.add(function(object){ send({ type: 'object_removed', data: { uuid: object.uuid } }); });
		signals.objectChanged.add(function(object){ send({ type: 'object_transformed', data: { uuid: object.uuid } }); });

		// Listen for commands from parent
		window.addEventListener('message', function(event) {
			// Filter out metamask and other extension messages
			if (!event.data || typeof event.data !== 'object' || event.data.target) return;

			const command = event.data;
			console.log('Three.js Editor received command:', command);

			switch (command.type) {
							case 'load_scene':
				// Clear current scene first
				editor.clear();
				console.log('Cleared scene, loading new data...');

				// Try to use ObjectLoader first for proper Three.js scene loading
				if (command.data && command.data.metadata && command.data.object) {
					try {
						console.log('Loading scene with ObjectLoader, textures:', command.data.textures?.length || 0, 'images:', command.data.images?.length || 0);
						
						const loader = new THREE.ObjectLoader();
						const loadedObject = loader.parse(command.data);
						
						// Post-process loaded objects to ensure textures are applied
						loadedObject.traverse((child) => {
							if (!child.isMesh) return;
							console.log('Processing mesh:', child.name, 'position:', child.position, 'userData:', child.userData);

							// Ensure correct geometry for media assets (force plane for image/video)
							const at = (child.userData && child.userData.assetType) || '';
							if ((at === 'image' || at === 'video') && !(child.geometry && child.geometry.isPlaneGeometry)) {
								child.geometry = new THREE.PlaneGeometry(2, 2);
							}

							// Re-apply saved transform defensively before media attaches
							if (Array.isArray(child.position)) child.position.fromArray(child.position);
							if (Array.isArray(child.rotation)) child.rotation.fromArray(child.rotation);
							if (Array.isArray(child.scale)) child.scale.fromArray(child.scale);

							const url = child.userData && child.userData.mediaUrl;
							if (!url) {
								console.log('Mesh has no mediaUrl:', child.name);
								return;
							}

							applyMediaToMesh(child, url, child.userData.assetType, editor);
						});
						
						editor.scene.add(loadedObject);
						
						// Update the editor
						editor.signals.sceneGraphChanged.dispatch();
						editor.signals.objectSelected.dispatch(null);
						
						console.log(`Scene loaded successfully with ${loadedObject.children.length} objects`);
						
						// Send success response
						send({
							type: 'scene_loaded',
							data: { success: true, objectCount: loadedObject.children.length },
							commandId: command.id
						});
						
					} catch (error) {
						console.error('ObjectLoader failed, falling back to manual creation:', error);
						// Fall back to manual object creation
						loadSceneManually(command, editor, send);
					}
				} else if (command.data && command.data.object && command.data.object.children) {
					// Manual object creation for simpler scene data
					loadSceneManually(command, editor, send);
				} else {
					console.log('No scene data or children found, scene remains empty');
					// Send success response even for empty scene
					send({
						type: 'scene_loaded',
						data: { success: true, objectCount: 0 },
						commandId: command.id
					});
				}
				break;

				case 'clear_scene':
					editor.clear();
					console.log('Scene cleared');
					break;

				case 'add_object':
					try {
						const objData = command.data;
						let geometry, material;

						// Create geometry
						switch (objData.geometry.type) {
							case 'BoxGeometry':
								geometry = new THREE.BoxGeometry(
									objData.geometry.width || 1,
									objData.geometry.height || 1,
									objData.geometry.depth || 1
								);
								break;
							case 'SphereGeometry':
								geometry = new THREE.SphereGeometry(objData.geometry.radius || 0.5);
								break;
							case 'PlaneGeometry':
								geometry = new THREE.PlaneGeometry(
									objData.geometry.width || 1,
									objData.geometry.height || 1
								);
								break;
							default:
								geometry = new THREE.BoxGeometry(1, 1, 1);
						}

						// Neutral base color; texture/video will set to white
						material = new THREE.MeshBasicMaterial({ color: 0x999999, side: THREE.DoubleSide });

						// Create mesh
						const mesh = new THREE.Mesh(geometry, material);
						mesh.name = objData.name || 'Object';
						mesh.position.fromArray(objData.position || [0, 0, 0]);
						if (objData.rotation) mesh.rotation.fromArray(objData.rotation);
						if (objData.scale) mesh.scale.fromArray(objData.scale);
						mesh.userData = objData.userData || {};
						editor.addObject(mesh);

						// Apply media if provided (image/video), same as load path
						if (objData.userData && objData.userData.mediaUrl) {
							console.log('Loading media for add_object:', objData.userData.mediaUrl);
							applyMediaToMesh(mesh, objData.userData.mediaUrl, objData.userData.assetType, editor);
						}

						console.log('Added object:', mesh.name);
						// Send success response
						send({ 
							type: 'object_added_success', 
							data: { success: true, uuid: mesh.uuid, name: mesh.name },
							commandId: command.id 
						});
					} catch (error) {
						console.error('Failed to add object:', error);
						send({ type: 'error', data: { error: 'Failed to add object: ' + error.message } });
					}
					break;

				case 'export_scene':
					try {
						console.log('Exporting scene...');
						const scene = editor.scene;
						const sceneJSON = scene.toJSON();
						console.log('Scene JSON:', sceneJSON);
						send({
							type: 'scene_exported',
							data: sceneJSON,
							commandId: command.id
						});
						console.log('Scene exported successfully');
					} catch (error) {
						console.error('Failed to export scene:', error);
						send({ type: 'error', data: { error: 'Failed to export scene: ' + error.message } });
					}
					break;
			}
		});

			//

			document.addEventListener( 'dragover', function ( event ) {

				event.preventDefault();
				event.dataTransfer.dropEffect = 'copy';

			} );

			document.addEventListener( 'drop', function ( event ) {

				event.preventDefault();

				if ( event.dataTransfer.types[ 0 ] === 'text/plain' ) return; // Outliner drop

				if ( event.dataTransfer.items ) {

					// DataTransferItemList supports folders

					editor.loader.loadItemList( event.dataTransfer.items );

				} else {

					editor.loader.loadFiles( event.dataTransfer.files );

				}

			} );

			// Manual scene loading function for fallback
			function loadSceneManually(command, editor, send) {
				try {
					command.data.object.children.forEach(child => {
						// Create basic geometry based on asset type
						let geometry, material;
						const assetType = child.userData?.assetType || 'unknown';

						switch (assetType) {
							case 'image':
							case 'video':
							case 'layout_reference':
							case 'layout':
								geometry = new THREE.PlaneGeometry(2, 2);
								// Support textured planes when mediaUrl is provided
								const url = child.userData && child.userData.mediaUrl;
								if (url) {
									console.log('Loading texture from userData.mediaUrl:', url);
									const textureLoader = new THREE.TextureLoader();
									textureLoader.crossOrigin = 'anonymous';
									// Create initial material
									material = new THREE.MeshBasicMaterial({
										color: assetType === 'image' ? 0x4f46e5 :
											   assetType === 'video' ? 0xef4444 : 0x8b5cf6,
										transparent: true,
										opacity: 0.9
									});
									
									// Load texture asynchronously and update material
									textureLoader.load(
										url,
										(texture) => {
											texture.colorSpace = THREE.SRGBColorSpace;
											texture.needsUpdate = true;
											material.map = texture;
											material.needsUpdate = true;
											console.log('Texture loaded successfully for load_scene:', child.name);
										},
										undefined,
										(error) => {
											console.warn('Failed to load texture for load_scene:', url, error);
										}
									);
								} else {
									material = new THREE.MeshBasicMaterial({
										color: assetType === 'image' ? 0x4f46e5 :
											   assetType === 'video' ? 0xef4444 : 0x8b5cf6,
										transparent: true,
										opacity: 0.9
									});
								}
								break;
							case 'audio':
								geometry = new THREE.SphereGeometry(0.5);
								material = new THREE.MeshBasicMaterial({ color: 0x10b981 });
								break;
							case 'text':
								geometry = new THREE.BoxGeometry(1, 0.5, 0.1);
								material = new THREE.MeshBasicMaterial({ color: 0xf59e0b });
								break;
							default:
								geometry = new THREE.BoxGeometry(1, 1, 1);
								material = new THREE.MeshBasicMaterial({ color: 0x6b7280 });
						}

						const mesh = new THREE.Mesh(geometry, material);
						mesh.name = child.name || child.userData?.assetId || 'Unknown';
						mesh.uuid = child.uuid;
						mesh.position.fromArray(child.position);
						mesh.rotation.fromArray(child.rotation);
						mesh.scale.fromArray(child.scale);
						mesh.userData = child.userData || {};

						editor.addObject(mesh);
					});
					console.log('Scene loaded manually with', command.data.object.children.length, 'objects');
					// Send success response
					send({
						type: 'scene_loaded',
						data: { success: true, objectCount: command.data.object.children.length },
						commandId: command.id
					});
				} catch (error) {
					console.error('Failed to load scene manually:', error);
					send({ type: 'error', data: { error: 'Failed to load scene: ' + error.message } });
				}
			}

			// Shared helper to apply image/video media to a mesh consistently
			function applyMediaToMesh(mesh, url, assetType, editor) {
				if (!url) return;
				const isVideo = (assetType === 'video') || /\.mp4(\?|$)/i.test(url);
				if (isVideo) {
					try {
						const video = document.createElement('video');
						video.src = url;
						video.crossOrigin = 'anonymous';
						video.muted = true;
						video.preload = 'auto';
						video.loop = true;
						video.playsInline = true;
						video.setAttribute('playsinline', '');
						video.setAttribute('muted', '');
						video.autoplay = true;
						const startPlayback = () => video.play().catch(() => {});
						video.addEventListener('loadeddata', () => {
							if (video.videoWidth === 0 || video.videoHeight === 0) return;
							const texture = new THREE.VideoTexture(video);
							texture.colorSpace = THREE.SRGBColorSpace;
							texture.generateMipmaps = false;
							texture.minFilter = THREE.LinearFilter;
							texture.magFilter = THREE.LinearFilter;
							if (!mesh.material || !(mesh.material instanceof THREE.MeshBasicMaterial)) {
								mesh.material = new THREE.MeshBasicMaterial({ side: THREE.DoubleSide });
							}
							mesh.material.color && mesh.material.color.set(0xffffff);
							mesh.material.map = texture;
							mesh.material.needsUpdate = true;
							if (editor.signals && editor.signals.materialChanged) {
								editor.signals.materialChanged.dispatch(mesh.material);
							}
							startPlayback();
						});
						video.addEventListener('error', (e) => {
							console.warn('Video failed to load:', url, e);
						});
						video.load();
						// User-gesture fallback
						video.play().catch(() => {
							const onInteract = () => { startPlayback(); document.removeEventListener('pointerdown', onInteract); document.removeEventListener('keydown', onInteract); };
							document.addEventListener('pointerdown', onInteract, { once: true });
							document.addEventListener('keydown', onInteract, { once: true });
						});
					} catch (e) {
						console.warn('Video setup error:', e);
					}
				} else {
					const textureLoader = new THREE.TextureLoader();
					textureLoader.crossOrigin = 'anonymous';
					textureLoader.load(
						url,
						(texture) => {
							texture.colorSpace = THREE.SRGBColorSpace;
							texture.format = THREE.RGBAFormat;
							texture.type = THREE.UnsignedByteType;
							texture.generateMipmaps = false;
							texture.minFilter = THREE.LinearFilter;
							texture.magFilter = THREE.LinearFilter;
							texture.wrapS = THREE.ClampToEdgeWrapping;
							texture.wrapT = THREE.ClampToEdgeWrapping;
							if (!mesh.material || !(mesh.material instanceof THREE.MeshBasicMaterial)) {
								mesh.material = new THREE.MeshBasicMaterial({ side: THREE.DoubleSide });
							}
							mesh.material.color && mesh.material.color.set(0xffffff);
							mesh.material.map = texture;
							mesh.material.needsUpdate = true;
							if (editor.signals && editor.signals.materialChanged) {
								editor.signals.materialChanged.dispatch(mesh.material);
							}
						},
						undefined,
						(error) => {
							console.error('Error loading texture for mesh:', mesh.name, error);
						}
					);
				}
			}

			function onWindowResize() {

				editor.signals.windowResize.dispatch();

			}

			window.addEventListener( 'resize', onWindowResize );

			onWindowResize();

			//

			let isLoadingFromHash = false;
			const hash = window.location.hash;

			if ( hash.slice( 1, 6 ) === 'file=' ) {

				const file = hash.slice( 6 );

				if ( confirm( editor.strings.getKey( 'prompt/file/open' ) ) ) {

					const loader = new THREE.FileLoader();
					loader.crossOrigin = '';
					loader.load( file, function ( text ) {

						editor.clear();
						editor.fromJSON( JSON.parse( text ) );

					} );

					isLoadingFromHash = true;

				}

			}

			// ServiceWorker

			if ( 'serviceWorker' in navigator ) {

				try {

					navigator.serviceWorker.register( 'sw.js' );

				} catch ( error ) {

				}

			}

		</script>
	</body>
</html>

// Redeploy marker: loader unchanged; textures only
