<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js editor</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link rel="apple-touch-icon" href="images/icon.png">
		<link rel="manifest" href="manifest.json">
		<link rel="shortcut icon" href="/favicon.ico" />
	</head>
	<body>
		<link rel="stylesheet" href="css/main.css">

		<script type="importmap">
			{
				"imports": {
					"three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js",
					"three/addons/": "/examples/jsm/",
					"three/examples/": "/examples/",
					"three-gpu-pathtracer": "https://cdn.jsdelivr.net/npm/three-gpu-pathtracer@0.0.23/build/index.module.js",
					"three-mesh-bvh": "https://cdn.jsdelivr.net/npm/three-mesh-bvh@0.7.4/build/index.module.js"
				}
			}
		</script>

		<script src="/examples/jsm/libs/draco/gltf/draco_decoder.js"></script>

		<link rel="stylesheet" href="js/libs/codemirror/codemirror.css">
		<link rel="stylesheet" href="js/libs/codemirror/theme/monokai.css">
		<script src="js/libs/codemirror/codemirror.js"></script>
		<script src="js/libs/codemirror/mode/javascript.js"></script>
		<script src="js/libs/codemirror/mode/glsl.js"></script>

		<script src="js/libs/esprima.js"></script>
		<script src="js/libs/jsonlint.js"></script>

		<script src="https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.11.6/dist/ffmpeg.min.js"></script>

		<link rel="stylesheet" href="js/libs/codemirror/addon/dialog.css">
		<link rel="stylesheet" href="js/libs/codemirror/addon/show-hint.css">
		<link rel="stylesheet" href="js/libs/codemirror/addon/tern.css">

		<script src="js/libs/codemirror/addon/dialog.js"></script>
		<script src="js/libs/codemirror/addon/show-hint.js"></script>
		<script src="js/libs/codemirror/addon/tern.js"></script>
		<script src="js/libs/acorn/acorn.js"></script>
		<script src="js/libs/acorn/acorn_loose.js"></script>
		<script src="js/libs/acorn/walk.js"></script>
		<script src="js/libs/ternjs/polyfill.js"></script>
		<script src="js/libs/ternjs/signal.js"></script>
		<script src="js/libs/ternjs/tern.js"></script>
		<script src="js/libs/ternjs/def.js"></script>
		<script src="js/libs/ternjs/comment.js"></script>
		<script src="js/libs/ternjs/infer.js"></script>
		<script src="js/libs/ternjs/doc_comment.js"></script>
		<script src="js/libs/tern-threejs/threejs.js"></script>
		<script src="js/libs/signals.min.js"></script>

		<script type="module">

			import * as THREE from 'three';

			import { Editor } from './js/Editor.js';
			import { Viewport } from './js/Viewport.js';
			import { Toolbar } from './js/Toolbar.js';
			import { Script } from './js/Script.js';
			import { Player } from './js/Player.js';
			import { Sidebar } from './js/Sidebar.js';
			import { Menubar } from './js/Menubar.js';
			import { Resizer } from './js/Resizer.js';

			window.URL = window.URL || window.webkitURL;
			window.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;

			//

			const editor = new Editor();

			window.editor = editor; // Expose editor to Console
			window.THREE = THREE; // Expose THREE to APP Scripts and Console

			const viewport = new Viewport( editor );
			document.body.appendChild( viewport.dom );

			const toolbar = new Toolbar( editor );
			document.body.appendChild( toolbar.dom );

			const script = new Script( editor );
			document.body.appendChild( script.dom );

			const player = new Player( editor );
			document.body.appendChild( player.dom );

			const sidebar = new Sidebar( editor );
			document.body.appendChild( sidebar.dom );

			const menubar = new Menubar( editor );
			document.body.appendChild( menubar.dom );

			const resizer = new Resizer( editor );
			document.body.appendChild( resizer.dom );

			// Helper: frame camera to scene or object with a tight fit
			function frameScene(editor, target) {
				try {
					const THREERef = THREE;
					const box = new THREERef.Box3().setFromObject(target || editor.scene);
					if (!box.isEmpty()) {
						const size = box.getSize(new THREERef.Vector3());
						const center = box.getCenter(new THREERef.Vector3());
						const maxDim = Math.max(size.x, size.y, size.z);
						const distance = maxDim * 1.2 + 0.6; // tighter fit
						editor.camera.position.set(center.x, center.y + maxDim * 0.5, center.z + distance);
						editor.camera.lookAt(center);
						if (editor.signals && editor.signals.cameraChanged) editor.signals.cameraChanged.dispatch();
						if (editor.signals && editor.signals.sceneGraphChanged) editor.signals.sceneGraphChanged.dispatch();
					}
				} catch {}
			}

			// Enhanced video controls overlay – anchored to selected video card bottom
			const controls = document.createElement('div');
			controls.style.cssText = 'position:absolute;left:0;top:0;display:none;gap:8px;align-items:center;background:#0b0b0de0;border:1px solid #1f2937;border-radius:10px;padding:8px 12px;color:#e5e7eb;font:12px system-ui;z-index:1000;box-shadow:0 6px 24px rgba(0,0,0,.5);backdrop-filter:blur(8px)';
			const playBtn = document.createElement('button');
			playBtn.textContent = '▶️';
			playBtn.style.cssText = 'background:#111827;color:#e5e7eb;border:1px solid #374151;border-radius:6px;padding:6px 12px;cursor:pointer;transition:all 0.2s;font-size:14px';
			playBtn.addEventListener('mouseenter', () => playBtn.style.background = '#1f2937');
			playBtn.addEventListener('mouseleave', () => playBtn.style.background = '#111827');

			const muteBtn = document.createElement('button');
			muteBtn.textContent = '🔊';
			muteBtn.style.cssText = playBtn.style.cssText;
			muteBtn.addEventListener('mouseenter', () => muteBtn.style.background = '#1f2937');
			muteBtn.addEventListener('mouseleave', () => muteBtn.style.background = '#111827');

			const timeLabel = document.createElement('span');
			timeLabel.textContent = '0:00 / 0:00';
			timeLabel.style.cssText = 'min-width:80px;text-align:center;font-family:monospace';

			const seek = document.createElement('input');
			seek.type = 'range';
			seek.min = '0';
			seek.max = '0';
			seek.step = '0.01';
			seek.style.cssText = 'width:280px;height:6px;background:#374151;border-radius:3px;outline:none;cursor:pointer';

			controls.appendChild(playBtn);
			controls.appendChild(muteBtn);
			controls.appendChild(seek);
			controls.appendChild(timeLabel);
			document.body.appendChild(controls);

			let boundVideo = null;
			let boundMesh = null;
			const videoMap = new Map(); // uuid -> HTMLVideoElement
			function fmtTime(t){ if(!isFinite(t)) return '0:00'; const m=Math.floor(t/60); const s=Math.floor(t%60); return m+':' + String(s).padStart(2,'0'); }
			function bindVideoForControls(mesh){
				boundMesh = null;
				boundVideo = null;
				if(!mesh){
					controls.style.display='none';
					console.log('No mesh selected, hiding controls');
					return;
				}
				const v = videoMap.get(mesh.uuid);
				if(!v){
					controls.style.display='none';
					console.log('No video found for mesh:', mesh.uuid);
					return;
				}
				boundMesh = mesh;
				boundVideo = v;
				controls.style.display='flex';
				console.log('Video controls bound to:', mesh.name, 'playing:', !v.paused);

				seek.max = isFinite(boundVideo.duration) ? String(boundVideo.duration) : '0';
				seek.value = String(boundVideo.currentTime || 0);
				timeLabel.textContent = `${fmtTime(boundVideo.currentTime||0)} / ${fmtTime(boundVideo.duration||0)}`;
				playBtn.textContent = boundVideo.paused ? '▶️' : '⏸️';
				muteBtn.textContent = boundVideo.muted ? '🔇' : '🔊';
				updateControlsPosition();
			}
			function updateControlsPosition(){
				if(!boundMesh){ return; }
				try{
					const box = new THREE.Box3().setFromObject(boundMesh);
					const size = box.getSize(new THREE.Vector3());
					const center = box.getCenter(new THREE.Vector3());
					const bottom = new THREE.Vector3(center.x, box.min.y, center.z);
					bottom.project(editor.camera);
					const vp = viewport.dom.getBoundingClientRect();
					const x = (bottom.x * 0.5 + 0.5) * vp.width + vp.left;
					const y = ( -bottom.y * 0.5 + 0.5) * vp.height + vp.top;
					// Place controls slightly below bottom edge
					controls.style.left = Math.round(x - controls.offsetWidth/2) + 'px';
					controls.style.top = Math.round(y + 8) + 'px';
				}catch{}
			}
			playBtn.onclick = ()=>{
				if(!boundVideo) return;
				console.log('Play button clicked, video paused:', boundVideo.paused);
				if(boundVideo.paused){
					boundVideo.play().then(() => {
						console.log('Video play succeeded');
						playBtn.textContent = '⏸️';
					}).catch((error) => {
						console.error('Video play failed:', error);
					});
				} else {
					boundVideo.pause();
					console.log('Video paused');
					playBtn.textContent = '▶️';
				}
			};
			muteBtn.onclick = ()=>{
				if(!boundVideo) return;
				boundVideo.muted = !boundVideo.muted;
				muteBtn.textContent = boundVideo.muted ? '🔇' : '🔊';
			};
			seek.oninput = ()=>{
				if(!boundVideo) return;
				try{
					const newTime = parseFloat(seek.value);
					console.log('Seeking to:', newTime);
					boundVideo.currentTime = newTime;
				}catch(error) {
					console.error('Seek failed:', error);
				}
			};
			function tick(){
				if(boundVideo){
					seek.max = isFinite(boundVideo.duration)? String(boundVideo.duration) : seek.max;
					seek.value = String(boundVideo.currentTime||0);
					timeLabel.textContent = `${fmtTime(boundVideo.currentTime||0)} / ${fmtTime(boundVideo.duration||0)}`;
					updateControlsPosition();
				}
				requestAnimationFrame(tick);
			}
			requestAnimationFrame(tick);
			window.addEventListener('resize', updateControlsPosition);

			// Helper: create/update a simple frame behind a mesh; non-selectable and marked to ignore save
			function ensureFrameForMesh(mesh, editor, pad = 0.06) {
				try {
					// Try to find an existing frame linked to this mesh
					let frame = null;
					if (editor.scene) {
						editor.scene.traverse(obj => {
							if (
								obj !== mesh &&
								obj.isMesh &&
								obj.userData &&
								obj.userData.ignoreSave &&
								obj.userData.parentUuid === mesh.uuid
							) frame = obj;
						});
					}
					if (!frame) {
						const mat = new THREE.MeshBasicMaterial({ color: 0x111111, side: THREE.DoubleSide });
						// Ensure the frame never occludes the media (no depth test/write; polygon offset)
						mat.depthTest = false;
						mat.depthWrite = false;
						mat.polygonOffset = true;
						mat.polygonOffsetFactor = 1;
						mat.polygonOffsetUnits = 1;

						frame = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), mat);
						frame.name = '_helper:VideoFrame';
						frame.userData = { ignoreSave: true, parentUuid: mesh.uuid, isHelper: true };
						// Make helper non-selectable by raycaster
						frame.raycast = function(){};
						// Add directly to scene so it doesn't pollute history/selection signals
						editor.scene.add(frame);
					}
					// Match transform and add slight backward offset along mesh normal to avoid coplanar z-fight
					frame.position.copy(mesh.position);
					frame.rotation.copy(mesh.rotation);
					frame.scale.set(Math.max(mesh.scale.x + pad, 0.01), Math.max(mesh.scale.y + pad, 0.01), 1);
					const offset = new THREE.Vector3(0, 0, -0.001).applyQuaternion(mesh.quaternion);
					frame.position.add(offset);
					frame.renderOrder = (mesh.renderOrder || 0) - 1;
				} catch {}
			}

			// Helper: force a few render ticks so new textures (image/video) present immediately
			function forceRenderTicks(mesh, editor, frames = 3) {
				let remaining = Math.max(1, frames);
				const tick = () => {
					try {
						if (mesh && mesh.material && mesh.material.map) {
							mesh.material.map.needsUpdate = true;
							mesh.material.needsUpdate = true;
						}
						if (editor.signals && editor.signals.objectChanged) editor.signals.objectChanged.dispatch(mesh);
						if (editor.signals && editor.signals.sceneGraphChanged) editor.signals.sceneGraphChanged.dispatch();
					} catch {}
					if (--remaining > 0) requestAnimationFrame(tick);
				};
				requestAnimationFrame(tick);
			}

		// Bullseye drag interaction functions (defined before initialization)
		let bullseyeRaycaster = new THREE.Raycaster();
		let bullseyeMouse = new THREE.Vector2();
		let bullseyeGroundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
		let isDraggingBullseye = false;

		function onBullseyeMouseDown(event) {
			if (!window.bullseyeMode || !window.bullseyeIndicator) return;

			console.log('Bullseye mousedown event triggered');

			// Check if we clicked on the bullseye
			const rect = editor.renderer.domElement.getBoundingClientRect();
			bullseyeMouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
			bullseyeMouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

			bullseyeRaycaster.setFromCamera(bullseyeMouse, editor.camera);
			const intersects = bullseyeRaycaster.intersectObject(window.bullseyeIndicator, true);

			console.log('Bullseye intersects:', intersects.length);

			if (intersects.length > 0) {
				isDraggingBullseye = true;
				editor.renderer.domElement.style.cursor = 'grabbing';
				console.log('Started dragging bullseye');
				event.preventDefault();
			}
		}

		function onBullseyeMouseMove(event) {
			if (!window.bullseyeMode || !window.bullseyeIndicator) return;

			const rect = editor.renderer.domElement.getBoundingClientRect();
			bullseyeMouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
			bullseyeMouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

			if (isDraggingBullseye) {
				// Drag the bullseye
				bullseyeRaycaster.setFromCamera(bullseyeMouse, editor.camera);
				
				const intersectPoint = new THREE.Vector3();
				bullseyeRaycaster.ray.intersectPlane(bullseyeGroundPlane, intersectPoint);
				
				if (intersectPoint) {
					window.bullseyeIndicator.position.x = intersectPoint.x;
					window.bullseyeIndicator.position.z = intersectPoint.z;
				}
			} else {
				// Check if hovering over bullseye for cursor change
				bullseyeRaycaster.setFromCamera(bullseyeMouse, editor.camera);
				const intersects = bullseyeRaycaster.intersectObject(window.bullseyeIndicator, true);
				
				if (intersects.length > 0) {
					editor.renderer.domElement.style.cursor = 'grab';
				} else {
					editor.renderer.domElement.style.cursor = 'default';
				}
			}
		}

		function onBullseyeMouseUp(event) {
			if (!window.bullseyeMode || !window.bullseyeIndicator) return;

			if (isDraggingBullseye) {
				isDraggingBullseye = false;
				editor.renderer.domElement.style.cursor = 'default';
				console.log('Bullseye positioned at:', [window.bullseyeIndicator.position.x, window.bullseyeIndicator.position.z]);
			}
		}

		function onBullseyeDoubleClick(event) {
			if (!window.bullseyeMode || !window.bullseyeIndicator) return;

			console.log('Bullseye double-click event triggered');

			// Check if we double-clicked on the bullseye
			const rect = editor.renderer.domElement.getBoundingClientRect();
			bullseyeMouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
			bullseyeMouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

			bullseyeRaycaster.setFromCamera(bullseyeMouse, editor.camera);
			const intersects = bullseyeRaycaster.intersectObject(window.bullseyeIndicator, true);

			console.log('Bullseye double-click intersects:', intersects.length);

			if (intersects.length > 0) {
				const position = [window.bullseyeIndicator.position.x, window.bullseyeIndicator.position.z];
				console.log('Bullseye placement at:', position);
				
				// Send placement event to parent
				send({ 
					type: 'bullseye_placement', 
					data: { position: position }
				});
				
				// Exit bullseye mode
				editor.scene.remove(window.bullseyeIndicator);
				window.bullseyeIndicator = null;
				window.bullseyeMode = false;
				editor.renderer.domElement.style.cursor = 'default';
			}
		}

		// Add timeout and error handling for storage initialization
		let initTimeout = setTimeout(() => {
			console.error('Editor storage initialization timed out, proceeding anyway');
			initializeEditor();
		}, 5000);

		function initializeEditor() {
			clearTimeout(initTimeout);

			// Add sample scene objects immediately
			// Scene will be loaded from space data via postMessage

			// Clear any cached scene data
			editor.clear();

			// Add bullseye event listeners after editor is ready
			if (editor.renderer && editor.renderer.domElement) {
				editor.renderer.domElement.addEventListener('mousedown', onBullseyeMouseDown);
				editor.renderer.domElement.addEventListener('mousemove', onBullseyeMouseMove);
				editor.renderer.domElement.addEventListener('mouseup', onBullseyeMouseUp);
				editor.renderer.domElement.addEventListener('dblclick', onBullseyeDoubleClick);
				console.log('Bullseye event listeners added');
			}

			console.log('Three.js Editor initialized successfully');
			try { window.parent.postMessage({ type: 'ready' }, '*'); } catch (e) {}
		}

		try {
			editor.storage.init( function () {
				clearTimeout(initTimeout);

				editor.storage.get( async function ( state ) {

					if ( isLoadingFromHash ) return;

					if ( state !== undefined ) {

						await editor.fromJSON( state );

					}

					const selected = editor.config.getKey( 'selected' );

					if ( selected !== undefined ) {

						editor.selectByUuid( selected );

					}

					initializeEditor();
				} );
			} );
		} catch (error) {
			console.error('Storage initialization failed:', error);
			initializeEditor();
		}

		//

		let timeout;

		function saveState() {

			if ( editor.config.getKey( 'autosave' ) === false ) {

				return;

			}

			clearTimeout( timeout );

			timeout = setTimeout( function () {

				editor.signals.savingStarted.dispatch();

				timeout = setTimeout( function () {

					// Use safe serialization that skips VideoTexture maps
					editor.storage.set( safeEditorToJSON(editor) );

					editor.signals.savingFinished.dispatch();

				}, 100 );

			}, 1000 );

		}

		// Safely serialize the scene by temporarily removing video material maps
		function safeEditorToJSON(editor){
			const removedMaps = [];
			try {
				editor.scene.traverse((obj)=>{
					try {
						if (obj && obj.isMesh && obj.material && obj.material.map) {
							const isVideoMesh = obj.userData?.assetType === 'video' || /VideoFrame/i.test(obj.name||'');
							if (isVideoMesh) {
								removedMaps.push({ material: obj.material, map: obj.material.map });
								obj.material.map = null;
								obj.material.needsUpdate = true;
							}
						}
					} catch {}
				});
				return editor.toJSON();
			} finally {
				// Restore maps
				for (const { material, map } of removedMaps) {
					try {
						material.map = map;
						material.needsUpdate = true;
					} catch {}
				}
			}
		}

		const signals = editor.signals;

		signals.geometryChanged.add( saveState );
		signals.objectAdded.add( saveState );
		signals.objectChanged.add( saveState );
		signals.objectRemoved.add( saveState );
		signals.materialChanged.add( saveState );
		signals.sceneBackgroundChanged.add( saveState );
		signals.sceneEnvironmentChanged.add( saveState );
		signals.sceneFogChanged.add( saveState );
		signals.sceneGraphChanged.add( saveState );
		signals.scriptChanged.add( saveState );
		signals.historyChanged.add( saveState );

		// Bridge: forward updates to parent
		function send(msg) { try { window.parent.postMessage(msg, '*'); } catch (e) {} }
		signals.objectSelected.add(function(object){
			send({ type: 'selection_changed', data: { selectedObjects: object ? [object.uuid] : [] } });
		});
		signals.objectAdded.add(function(object){ send({ type: 'object_added', data: { uuid: object.uuid } }); });
		signals.objectRemoved.add(function(object){ send({ type: 'object_removed', data: { uuid: object.uuid } }); });
		signals.objectChanged.add(function(object){ send({ type: 'object_transformed', data: { uuid: object.uuid } }); });

		// Listen for commands from parent
		window.addEventListener('message', function(event) {
			// Filter out metamask and other extension messages
			if (!event.data || typeof event.data !== 'object' || event.data.target) return;

			const command = event.data;
			console.log('Three.js Editor received command:', command);

			switch (command.type) {
							case 'load_scene':
				// Clear current scene first
				editor.clear();
				console.log('Cleared scene, loading new data...');

				// Use manual scene loading to avoid ObjectLoader texture issues
				if (command.data && command.data.metadata && command.data.object) {
					try {
						console.log('Loading scene manually to avoid ObjectLoader texture issues');

						// Create a new group to hold all objects
						const sceneGroup = new THREE.Group();

						// Process each object manually
						if (command.data.object.children) {
							command.data.object.children.forEach((childData) => {
								if (childData.type === 'Mesh') {
									// Create geometry
									let geometry;
									if (childData.geometry.type === 'PlaneGeometry') {
										geometry = new THREE.PlaneGeometry(1, 1);
									} else {
										geometry = new THREE.PlaneGeometry(1, 1); // Default to plane
									}

									// Create material
									const material = new THREE.MeshBasicMaterial({
										side: THREE.DoubleSide,
										toneMapped: false,
										color: 0xffffff
									});

									// Create mesh
									const mesh = new THREE.Mesh(geometry, material);

									// Set position
									if (childData.position) {
										mesh.position.set(childData.position[0], childData.position[1], childData.position[2]);
									}

									// Set rotation
									if (childData.rotation) {
										mesh.rotation.set(childData.rotation[0], childData.rotation[1], childData.rotation[2]);
									}

									// Set scale
									if (childData.scale) {
										mesh.scale.set(childData.scale[0], childData.scale[1], childData.scale[2]);
									}

									// Copy userData
									if (childData.userData) {
										mesh.userData = { ...childData.userData };
									}

																		// Set name and UUID consistently
									// For layout items, use the layoutItemId as the name for consistency
									if (childData.userData && childData.userData.layoutItemId) {
										mesh.name = childData.userData.layoutItemId;
									} else {
										mesh.name = childData.name || childData.uuid;
									}
									mesh.uuid = childData.uuid;

									// Debug: Log UUID assignment
									console.log('Mesh created:', mesh.name, 'UUID:', mesh.uuid);

									// Add to scene group
									sceneGroup.add(mesh);

									// Apply media if it has a mediaUrl
									const url = mesh.userData && mesh.userData.mediaUrl;
									if (url) {
										console.log('Processing mesh:', mesh.name, 'position:', mesh.position, 'userData:', mesh.userData);
										applyMediaToMesh(mesh, url, mesh.userData.assetType, editor);
									} else {
																		console.log('Mesh has no mediaUrl:', mesh.name);
								if (mesh.userData && (mesh.userData.assetType === 'text' || mesh.userData.contentType === 'text')) {
									const textContent = mesh.userData.fullTextContent || mesh.userData.text || mesh.name;
									console.log('Applying text content to mesh:', mesh.name, 'Content length:', textContent.length);
									applyTextToMesh(mesh, textContent, editor);
								}
									}
								}
							});
						}

						editor.scene.add(sceneGroup);
						frameScene(editor, sceneGroup);
						// Reframe after first render tick to ensure bounds are final
						requestAnimationFrame(()=> frameScene(editor, sceneGroup));

						// Update the editor
						editor.signals.sceneGraphChanged.dispatch();
						editor.signals.objectSelected.dispatch(null);

						console.log(`Scene loaded successfully with ${sceneGroup.children.length} objects`);

						// Debug: List all objects and their video mapping status
						sceneGroup.children.forEach((child, index) => {
							console.log(`Object ${index}: name="${child.name}", uuid="${child.uuid}", hasVideo=${videoMap.has(child.uuid)}`);
						});

						// Hook selection to show controls for videos
						try {
							// Clear any existing handlers first
							editor.signals.objectSelected.dispatch = editor.signals.objectSelected.dispatch || function() {};

							editor.signals.objectSelected.add(function(object){
								console.log('Object selected:', object?.name, object?.uuid);
								// If a helper frame was selected, resolve to the parent mesh
								if (object && object.userData && object.userData.isHelper && object.userData.parentUuid) {
									let parentMesh = null;
									editor.scene.traverse((o)=>{ if (o.uuid === object.userData.parentUuid) parentMesh = o; });
									if (parentMesh) object = parentMesh;
								}
								console.log('VideoMap has keys:', Array.from(videoMap.keys()));
								console.log('VideoMap has selected UUID?', object ? videoMap.has(object.uuid) : 'no object');
								if (object && videoMap.has(object.uuid)) {
									console.log('Binding video controls for:', object.name);
									bindVideoForControls(object);
								} else {
									console.log('No video found for selected object or no object selected');
									bindVideoForControls(null);
								}
							});
							console.log('Video selection handler bound successfully');
						} catch (error) {
							console.error('Failed to bind video controls:', error);
						}

						// Send success response
						send({
							type: 'scene_loaded',
							data: { success: true, objectCount: sceneGroup.children.length },
							commandId: command.id
						});

					} catch (error) {
						console.error('Manual scene loading failed:', error);
						// Send error response
						send({
							type: 'scene_loaded',
							data: { success: false, error: error.message },
							commandId: command.id
						});
					}
				} else if (command.data && command.data.object && command.data.object.children) {
					// Use the same manual loading approach for simpler scene data
					try {
						console.log('Loading simpler scene data manually');

						// Create a new group to hold all objects
						const sceneGroup = new THREE.Group();

						// Process each object manually
						command.data.object.children.forEach((childData) => {
							if (childData.type === 'Mesh') {
								// Create geometry (support custom shapes)
								let geometry;
								const g = childData.geometry || {};
								switch (g.type) {
									case 'SphereGeometry': {
										const radius = g.radius ?? 1; const w = g.widthSegments ?? 32; const h = g.heightSegments ?? 16;
										geometry = new THREE.SphereGeometry(radius, w, h); break;
									}
									case 'BoxGeometry': {
										const w = g.width ?? 1; const h = g.height ?? 1; const d = g.depth ?? 1;
										geometry = new THREE.BoxGeometry(w, h, d); break;
									}
									case 'CylinderGeometry': {
										const rt = g.radiusTop ?? 1; const rb = g.radiusBottom ?? 1; const hh = g.height ?? 1; const seg = g.radialSegments ?? 32;
										geometry = new THREE.CylinderGeometry(rt, rb, hh, seg); break;
									}
									case 'TorusGeometry': {
										const r = g.radius ?? 1; const tube = g.tube ?? 0.4; const rs = g.radialSegments ?? 16; const ts = g.tubularSegments ?? 100;
										geometry = new THREE.TorusGeometry(r, tube, rs, ts); break;
									}
									case 'TetrahedronGeometry': {
										const r = g.radius ?? 1; const detail = g.detail ?? 0; geometry = new THREE.TetrahedronGeometry(r, detail); break;
									}
									case 'OctahedronGeometry': {
										const r = g.radius ?? 1; const detail = g.detail ?? 0; geometry = new THREE.OctahedronGeometry(r, detail); break;
									}
									case 'IcosahedronGeometry': {
										const r = g.radius ?? 1; const detail = g.detail ?? 0; geometry = new THREE.IcosahedronGeometry(r, detail); break;
									}
									case 'DodecahedronGeometry': {
										const r = g.radius ?? 1; const detail = g.detail ?? 0; geometry = new THREE.DodecahedronGeometry(r, detail); break;
									}
									case 'PlaneGeometry':
									default: {
										const ww = g.width ?? 1; const hh = g.height ?? 1; geometry = new THREE.PlaneGeometry(ww, hh); break;
									}
								}

								// Create material
								const material = new THREE.MeshBasicMaterial({
									side: THREE.DoubleSide,
									toneMapped: false,
									color: 0xffffff
								});

								// Create mesh
								const mesh = new THREE.Mesh(geometry, material);

								// Set position
								if (childData.position) {
									mesh.position.set(childData.position[0], childData.position[1], childData.position[2]);
								}

								// Set rotation
								if (childData.rotation) {
									mesh.rotation.set(childData.rotation[0], childData.rotation[1], childData.rotation[2]);
								}

								// Set scale
								if (childData.scale) {
									mesh.scale.set(childData.scale[0], childData.scale[1], childData.scale[2]);
								}

								// Copy userData
								if (childData.userData) {
									mesh.userData = { ...childData.userData };
								}

								// Set name
								mesh.name = childData.name || childData.uuid;
								mesh.uuid = childData.uuid;

								// Add to scene group
								sceneGroup.add(mesh);

								// Apply media if it has a mediaUrl
								const url = mesh.userData && mesh.userData.mediaUrl;
								if (url) {
									console.log('Processing mesh:', mesh.name, 'position:', mesh.position, 'userData:', mesh.userData);
									applyMediaToMesh(mesh, url, mesh.userData.assetType, editor);
								} else {
																	console.log('Mesh has no mediaUrl:', mesh.name);
								if (mesh.userData && (mesh.userData.assetType === 'text' || mesh.userData.contentType === 'text')) {
									const textContent = mesh.userData.fullTextContent || mesh.userData.text || mesh.name;
									console.log('Applying text content to mesh:', mesh.name, 'Content length:', textContent.length);
									applyTextToMesh(mesh, textContent, editor);
								}
								}
							}
						});

						editor.scene.add(sceneGroup);
						frameScene(editor, sceneGroup);
						// Reframe after first render tick to ensure bounds are final
						requestAnimationFrame(()=> frameScene(editor, sceneGroup));

						// Update the editor
						editor.signals.sceneGraphChanged.dispatch();
						editor.signals.objectSelected.dispatch(null);

						console.log(`Scene loaded successfully with ${sceneGroup.children.length} objects`);

						// Send success response
						send({
							type: 'scene_loaded',
							data: { success: true, objectCount: sceneGroup.children.length },
							commandId: command.id
						});

					} catch (error) {
						console.error('Simpler scene loading failed:', error);
						send({
							type: 'scene_loaded',
							data: { success: false, error: error.message },
							commandId: command.id
						});
					}
				} else {
					console.log('No scene data or children found, scene remains empty');
					// Send success response even for empty scene
					send({
						type: 'scene_loaded',
						data: { success: true, objectCount: 0 },
						commandId: command.id
					});
				}
				break;

				case 'clear_scene':
					editor.clear();
					console.log('Scene cleared');
					break;

				case 'add_object':
					try {
						const objData = command.data;
						let geometry, material;
						const assetType = (objData.userData && objData.userData.assetType) ? String(objData.userData.assetType).toLowerCase() : '';
						const isMediaPlane = ['image','video','text','layout','canvas'].includes(assetType);

						// Create geometry
						if (isMediaPlane || objData.geometry.type === 'PlaneGeometry') {
							geometry = new THREE.PlaneGeometry(
								objData.geometry.width || 1,
								objData.geometry.height || 1
							);
						} else if (objData.geometry.type === 'BoxGeometry') {
							geometry = new THREE.BoxGeometry(
								objData.geometry.width || 1,
								objData.geometry.height || 1,
								objData.geometry.depth || 1
							);
						} else if (objData.geometry.type === 'SphereGeometry') {
							geometry = new THREE.SphereGeometry(objData.geometry.radius || 0.5);
						} else {
							// Default to plane to match load behavior
							geometry = new THREE.PlaneGeometry(1, 1);
						}

						// Match load path: white base, DoubleSide, no tone mapping
						material = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, toneMapped: false });

						// Create mesh
						const mesh = new THREE.Mesh(geometry, material);
						mesh.name = objData.name || 'Object';
						mesh.position.fromArray(objData.position || [0, 0, 0]);
						if (objData.rotation) mesh.rotation.fromArray(objData.rotation);
						if (objData.scale) mesh.scale.fromArray(objData.scale);
						mesh.userData = objData.userData || {};
						editor.addObject(mesh);

						// Apply media if provided (image/video), same as load path
						if (objData.userData && objData.userData.mediaUrl) {
							console.log('Loading media for add_object:', objData.userData.mediaUrl);
							applyMediaToMesh(mesh, objData.userData.mediaUrl, objData.userData.assetType, editor);
						} else if (assetType === 'text' || (objData.userData && objData.userData.contentType === 'text')) {
												// Render text with full content if available
					const textContent = objData.userData?.fullTextContent || objData.userData?.text || objData.text || mesh.name;
					console.log('Applying text content to mesh:', mesh.name, 'Content length:', textContent.length);
					applyTextToMesh(mesh, textContent, editor);
						}

						console.log('Added object:', mesh.name);
						// Send success response
						send({
							type: 'object_added_success',
							data: { success: true, uuid: mesh.uuid, name: mesh.name },
							commandId: command.id
						});
					} catch (error) {
						console.error('Failed to add object:', error);
						send({ type: 'error', data: { error: 'Failed to add object: ' + error.message } });
					}
					break;

				case 'export_scene':
					try {
						console.log('Exporting scene...');
						// Use safe serialization that strips video maps and helpers
						const sceneJSON = (function safeSerialize(editor){
							const removedHelpers = [];
							const removedVideoMaps = [];
							try {
								// Remove helper objects
								editor.scene.traverse((obj)=>{
									try {
										if (obj.userData && obj.userData.ignoreSave && obj.parent) {
											removedHelpers.push({ obj, parent: obj.parent });
										}
										// Temporarily clear video maps so three can serialize
										if (obj.isMesh && obj.material && obj.material.map && obj.userData?.assetType === 'video') {
											removedVideoMaps.push({ material: obj.material, map: obj.material.map });
											obj.material.map = null;
											obj.material.needsUpdate = true;
										}
									} catch {}
								});
								removedHelpers.forEach(({ obj, parent }) => { try { parent.remove(obj); } catch {} });
								const json = editor.scene.toJSON();
								// Persist camera pose into userData so the viewer can match the editor view
								try {
									const cam = editor.camera;
									json.userData = json.userData || {};
									json.userData.camera = {
										position: [cam.position.x, cam.position.y, cam.position.z],
										target: (function(){
											const t = new THREE.Vector3(0,0,-1).applyQuaternion(cam.quaternion).add(cam.position);
											return [t.x, t.y, t.z];
										})(),
										quaternion: [cam.quaternion.x, cam.quaternion.y, cam.quaternion.z, cam.quaternion.w],
										fov: cam.fov
									};
								} catch (e) { console.warn('Failed to serialize camera pose', e); }
								// Restore
								removedHelpers.forEach(({ obj, parent }) => { try { parent.add(obj); } catch {} });
								for (const { material, map } of removedVideoMaps) { try { material.map = map; material.needsUpdate = true; } catch {} }
								return json;
							} finally {}
						})(editor);
						console.log('Scene JSON:', sceneJSON);
						send({ type: 'scene_exported', data: sceneJSON, commandId: command.id });
						console.log('Scene exported successfully');
					} catch (error) {
						console.error('Failed to export scene:', error);
						send({ type: 'error', data: { error: 'Failed to export scene: ' + error.message } });
					}
					break;

				case 'enter_bullseye_mode':
					try {
						// Create bullseye indicator
						if (!window.bullseyeIndicator) {
							// Create a more visible bullseye with both ring and center
							const group = new THREE.Group();
							
							// Outer ring
							const ringGeometry = new THREE.RingGeometry(0.8, 1.0, 16);
							const ringMaterial = new THREE.MeshBasicMaterial({
								color: 0xff4444,
								side: THREE.DoubleSide,
								transparent: true,
								opacity: 0.8
							});
							const ring = new THREE.Mesh(ringGeometry, ringMaterial);
							
							// Inner circle for easier clicking
							const circleGeometry = new THREE.CircleGeometry(0.8, 16);
							const circleMaterial = new THREE.MeshBasicMaterial({
								color: 0xff4444,
								side: THREE.DoubleSide,
								transparent: true,
								opacity: 0.3
							});
							const circle = new THREE.Mesh(circleGeometry, circleMaterial);
							
							group.add(ring);
							group.add(circle);
							group.rotation.x = -Math.PI / 2; // Lay flat on ground
							group.position.set(0, 0.01, 0); // Slightly above ground
							group.userData.ignoreSave = true; // Don't save with scene
							
							window.bullseyeIndicator = group;
							editor.scene.add(window.bullseyeIndicator);
						}

						// Enable bullseye mode
						window.bullseyeMode = true;
						isDraggingBullseye = false; // Reset drag state
						console.log('Entered bullseye placement mode at (0,0)');
						send({ type: 'bullseye_mode_entered', data: { success: true }, commandId: command.id });
					} catch (error) {
						console.error('Failed to enter bullseye mode:', error);
						send({ type: 'error', data: { error: 'Failed to enter bullseye mode: ' + error.message } });
					}
					break;

				case 'exit_bullseye_mode':
					try {
						// Remove bullseye indicator
						if (window.bullseyeIndicator) {
							editor.scene.remove(window.bullseyeIndicator);
							window.bullseyeIndicator = null;
						}

						// Disable bullseye mode
						window.bullseyeMode = false;
						console.log('Exited bullseye placement mode');
						send({ type: 'bullseye_mode_exited', data: { success: true }, commandId: command.id });
					} catch (error) {
						console.error('Failed to exit bullseye mode:', error);
						send({ type: 'error', data: { error: 'Failed to exit bullseye mode: ' + error.message } });
					}
					break;
			}
		});

				// Event listeners will be added after editor initialization

			//

			document.addEventListener( 'dragover', function ( event ) {

				event.preventDefault();
				event.dataTransfer.dropEffect = 'copy';

			} );

			document.addEventListener( 'drop', function ( event ) {

				event.preventDefault();

				if ( event.dataTransfer.types[ 0 ] === 'text/plain' ) return; // Outliner drop

				if ( event.dataTransfer.items ) {

					// DataTransferItemList supports folders

					editor.loader.loadItemList( event.dataTransfer.items );

				} else {

					editor.loader.loadFiles( event.dataTransfer.files );

				}

			} );



						// Shared helper to apply image/video media to a mesh consistently
			function applyMediaToMesh(mesh, url, assetType, editor) {
				if (!url) return;
				const isVideo = (assetType === 'video') || /\.mp4(\?|$)/i.test(url);
				console.log('applyMediaToMesh:', mesh.name, 'url:', url, 'assetType:', assetType, 'isVideo:', isVideo);
				if (isVideo) {
					console.log('Creating video texture for:', mesh.name);

					// Create video element
					const video = document.createElement('video');
					video.src = url;
					video.crossOrigin = 'anonymous';
					video.muted = true;
					video.loop = true;
					video.playsInline = true;
					video.autoplay = false;
					video.style.display = 'none';
					document.body.appendChild(video);

					console.log('Video element created, src:', video.src);

					// Wait for video to be ready before creating texture
					video.addEventListener('loadeddata', () => {
						console.log('Video loaded data, ready state:', video.readyState);

							// Create VideoTexture only when video is ready
							const videoTexture = new THREE.VideoTexture(video);
							videoTexture.minFilter = THREE.LinearFilter;
							videoTexture.magFilter = THREE.LinearFilter;
							videoTexture.format = THREE.RGBAFormat;
							videoTexture.type = THREE.UnsignedByteType;
							videoTexture.colorSpace = THREE.SRGBColorSpace;
							videoTexture.generateMipmaps = false;
							videoTexture.wrapS = THREE.ClampToEdgeWrapping;
							videoTexture.wrapT = THREE.ClampToEdgeWrapping;
							videoTexture.flipY = true;

							console.log('VideoTexture created with ready video');

							// Apply to material
							const videoMaterial = new THREE.MeshBasicMaterial({ map: videoTexture, side: THREE.DoubleSide, toneMapped: false });
							mesh.material = videoMaterial;
							mesh.material.needsUpdate = true;

							console.log('Material applied to mesh');

							// Start video
							// Try to start; if blocked, ensure first frame shows
							video.play().then(() => {
								console.log('Video playing successfully');
								videoTexture.needsUpdate = true;
								console.log('Forced initial texture update');
								// Force a render update to ensure video appears
								if (editor.signals && editor.signals.sceneGraphChanged) {
									editor.signals.sceneGraphChanged.dispatch();
								}
								forceRenderTicks(mesh, editor, 4);
							}).catch(err => {
								console.log('Video autoplay failed, will play on user interaction:', err);
								// Even if play fails, draw the first frame as soon as it can play
								const showFirstFrame = () => { try { videoTexture.needsUpdate = true; forceRenderTicks(mesh, editor, 4); if (editor.signals && editor.signals.sceneGraphChanged) editor.signals.sceneGraphChanged.dispatch(); } catch {} }
								video.addEventListener('canplay', showFirstFrame, { once: true });
								video.addEventListener('loadedmetadata', showFirstFrame, { once: true });
							});

							// Also nudge updates when player becomes ready
							const bumpUpdate = () => { try { videoTexture.needsUpdate = true; } catch {} };
							video.addEventListener('canplay', bumpUpdate, { once: true });
							video.addEventListener('loadedmetadata', bumpUpdate, { once: true });

							// Track video element
							videoMap.set(mesh.uuid, video);
							console.log('Video mapped for mesh:', mesh.uuid, 'mesh.name:', mesh.name);
							console.log('VideoMap now has:', Array.from(videoMap.keys()));

							// Notify editor
							if (editor.signals && editor.signals.materialChanged) {
								editor.signals.materialChanged.dispatch(mesh.material);
							}
							if (editor.signals && editor.signals.sceneGraphChanged) {
								editor.signals.sceneGraphChanged.dispatch();
							}
							// Do not create helper frame for images (keep scene clean)
						});

					// Handle video load errors
					video.addEventListener('error', (e) => {
						console.error('Video load error:', e);
					});
				} else {
					console.log('Loading image texture for:', mesh.name, 'URL:', url);
					const textureLoader = new THREE.TextureLoader();
					textureLoader.crossOrigin = 'anonymous';
					textureLoader.load(
						url,
						(texture) => {
							console.log('Image texture loaded successfully for:', mesh.name);
							// Configure texture properties
							texture.colorSpace = THREE.SRGBColorSpace;
							texture.format = THREE.RGBAFormat;
							texture.type = THREE.UnsignedByteType;
							texture.generateMipmaps = false;
							texture.minFilter = THREE.LinearFilter;
							texture.magFilter = THREE.LinearFilter;
							texture.wrapS = THREE.ClampToEdgeWrapping;
							texture.wrapT = THREE.ClampToEdgeWrapping;
							texture.flipY = true;

							// Wait for image to be fully loaded before applying texture
							const applyTextureWhenReady = () => {
								if (texture.image && texture.image.complete && texture.image.naturalWidth > 0) {
									console.log('Image ready, applying texture to:', mesh.name);

									if (!mesh.material || !(mesh.material instanceof THREE.MeshBasicMaterial)) {
										mesh.material = new THREE.MeshBasicMaterial({ side: THREE.DoubleSide, toneMapped: false });
									}
									mesh.material.color && mesh.material.color.set(0xffffff);
									mesh.material.map = texture;
									mesh.material.needsUpdate = true;
									texture.needsUpdate = true;
									forceRenderTicks(mesh, editor, 2);

								} else {
									console.log('Image not ready yet, waiting...', mesh.name);
									requestAnimationFrame(applyTextureWhenReady);
								}
							};

							applyTextureWhenReady();
						},
						undefined,
						(error) => {
							console.error('Error loading texture for mesh:', mesh.name, error);
							// Create a fallback material for failed textures
							if (!mesh.material || !(mesh.material instanceof THREE.MeshBasicMaterial)) {
								mesh.material = new THREE.MeshBasicMaterial({
									side: THREE.DoubleSide,
									toneMapped: false,
									color: 0xff0000 // Red color to indicate error
								});
							}
						}
					);
				}
			}

			// Render text to a canvas and apply as a texture to the mesh
			(function(){
				const textScrollState = new Map(); // uuid -> { scrollY, totalHeight }
				const textCanvasMap = new WeakMap(); // Mesh -> { canvas, ctx, padding, maxWidth, lineHeight, textContent, texture }
				let selectedTextMesh = null;
				function wrapLines(ctx, text, maxWidth){
					const words = (text || '').toString().replace(/\s+/g, ' ').trim().split(' ');
					const lines = [];
					let line = '';
					for(let i=0;i<words.length;i++){
						const test = line ? line + ' ' + words[i] : words[i];
						if(ctx.measureText(test).width > maxWidth && i>0){
							lines.push(line);
							line = words[i];
						}else{
							line = test;
						}
					}
					if(line) lines.push(line);
					return lines;
				}
				function renderTextMesh(mesh){
					try{
						const state = textScrollState.get(mesh.uuid) || { scrollY:0, totalHeight:0 };
						const entry = textCanvasMap.get(mesh) || {};
						const { canvas, ctx, padding, maxWidth, lineHeight, textContent, texture } = entry;
						if(!canvas || !ctx) return;
						// background
						ctx.fillStyle = '#ffffff';
						ctx.fillRect(0,0,canvas.width,canvas.height);
						ctx.fillStyle = '#111111';
						ctx.textBaseline = 'top';
						ctx.font = 'bold 48px system-ui, -apple-system, Segoe UI, Roboto, Arial';
						const lines = wrapLines(ctx, textContent, maxWidth);
						const contentHeight = lines.length * lineHeight + padding * 2;
						state.totalHeight = contentHeight;
						// clamp scroll
						const maxScroll = Math.max(0, contentHeight - canvas.height);
						state.scrollY = Math.max(0, Math.min(state.scrollY, maxScroll));
						// draw visible lines
						let y = padding - state.scrollY;
						for(const ln of lines){
							if(y > canvas.height - padding) break;
							if(y + lineHeight >= padding) ctx.fillText(ln, padding, y, maxWidth);
							y += lineHeight;
						}
						// scrollbar
						if(maxScroll > 1){
							const barW = Math.max(8, Math.round(canvas.width * 0.012));
							const trackX = canvas.width - padding/2 - barW;
							const trackY = padding;
							const trackH = canvas.height - padding*2;
							ctx.fillStyle = '#e5e7eb';
							ctx.fillRect(trackX, trackY, barW, trackH);
							const thumbH = Math.max(20, trackH * (canvas.height / contentHeight));
							const thumbY = trackY + (trackH - thumbH) * (state.scrollY / maxScroll);
							ctx.fillStyle = '#9ca3af';
							ctx.fillRect(trackX, Math.round(thumbY), barW, Math.round(thumbH));
						}
						texture.needsUpdate = true;
						if (mesh.material) mesh.material.needsUpdate = true;
						forceRenderTicks(mesh, editor, 2);
						textScrollState.set(mesh.uuid, state);
					}catch{}
				}
				function scrollText(mesh, deltaY){
					const state = textScrollState.get(mesh.uuid) || { scrollY:0, totalHeight:0 };
					state.scrollY += Math.sign(deltaY) * 40; // scroll step
					textScrollState.set(mesh.uuid, state);
					renderTextMesh(mesh);
				}
				// Public API used above
				window.applyTextToMesh = function(mesh, text, editor){
					try{
						const safeText = (text || '').toString();
						const desiredAspect = (mesh && mesh.scale) ? Math.max(0.1, mesh.scale.y / Math.max(mesh.scale.x, 0.001)) : 0.5;
						const baseWidth = 1024;
						const baseHeight = Math.max(512, Math.round(baseWidth * desiredAspect));
						const canvas = document.createElement('canvas');
						canvas.width = baseWidth;
						canvas.height = baseHeight;
						const ctx = canvas.getContext('2d');
						if(!ctx) return;
						const padding = Math.round(canvas.width * 0.06);
						const maxWidth = canvas.width - padding*2 - Math.round(canvas.width*0.04); // reserve for scrollbar
						const lineHeight = 60;
						const texture = new THREE.CanvasTexture(canvas);
						texture.colorSpace = THREE.SRGBColorSpace;
						texture.generateMipmaps = false;
						texture.minFilter = THREE.LinearFilter;
						texture.magFilter = THREE.LinearFilter;
						texture.wrapS = THREE.ClampToEdgeWrapping;
						texture.wrapT = THREE.ClampToEdgeWrapping;
						texture.flipY = true; // Align with images/videos to prevent upside-down on import
						if (!mesh.material || !(mesh.material instanceof THREE.MeshBasicMaterial)) {
							mesh.material = new THREE.MeshBasicMaterial({ side: THREE.FrontSide, toneMapped: false });
						}
						// Ensure readable text (avoid mirrored backside)
						mesh.material.side = THREE.FrontSide;
						mesh.material.toneMapped = false;
						mesh.material.color && mesh.material.color.set(0xffffff);
						mesh.material.map = texture;
						mesh.material.needsUpdate = true;
						textCanvasMap.set(mesh, { canvas, ctx, padding, maxWidth, lineHeight, textContent: safeText, texture });
						textScrollState.set(mesh.uuid, { scrollY: 0, totalHeight: 0 });
						renderTextMesh(mesh);
					}catch{}
				}
				// Selection + wheel scrolling (robust)
				function isTextMesh(obj){
					if(!obj) return false;
					const t1 = (obj.userData?.assetType||'').toString().toLowerCase();
					const t2 = (obj.userData?.contentType||'').toString().toLowerCase();
					const looksLikeCanvas = !!(obj.material && obj.material.map && obj.material.map.isCanvasTexture);
					return t1 === 'text' || t2 === 'text' || looksLikeCanvas;
				}
				signals.objectSelected.add(function(object){
					if(isTextMesh(object)){
						selectedTextMesh = object;
						console.log('[TextScroll] selected text mesh:', object.name);
					}else{
						selectedTextMesh = null;
					}
				});
				function onWheelScroll(e){
					if(selectedTextMesh){
						try{ e.preventDefault(); }catch{}
						scrollText(selectedTextMesh, e.deltaY);
					}
				}
				// Attach both to viewport and document to catch wheel consistently
				viewport.dom.addEventListener('wheel', onWheelScroll, { passive: false });
				document.addEventListener('wheel', onWheelScroll, { passive: false });
			})();

			function onWindowResize() {

				editor.signals.windowResize.dispatch();

			}

			window.addEventListener( 'resize', onWindowResize );

			onWindowResize();

			//

			let isLoadingFromHash = false;
			const hash = window.location.hash;

			if ( hash.slice( 1, 6 ) === 'file=' ) {

				const file = hash.slice( 6 );

				if ( confirm( editor.strings.getKey( 'prompt/file/open' ) ) ) {

					const loader = new THREE.FileLoader();
					loader.crossOrigin = '';
					loader.load( file, function ( text ) {

						editor.clear();
						editor.fromJSON( JSON.parse( text ) );

					} );

					isLoadingFromHash = true;

				}

			}

			// ServiceWorker

			if ( 'serviceWorker' in navigator ) {

				try {

					navigator.serviceWorker.register( 'sw.js' );

				} catch ( error ) {

				}

			}

		</script>
	</body>
</html>

// Redeploy marker: loader unchanged; textures only
