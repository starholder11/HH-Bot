<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js editor</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link rel="apple-touch-icon" href="images/icon.png">
		<link rel="manifest" href="manifest.json">
		<link rel="shortcut icon" href="/favicon.ico" />
	</head>
	<body>
		<link rel="stylesheet" href="css/main.css">

		<script type="importmap">
			{
				"imports": {
					"three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js",
					"three/addons/": "/examples/jsm/",
					"three/examples/": "/examples/",
					"three-gpu-pathtracer": "https://cdn.jsdelivr.net/npm/three-gpu-pathtracer@0.0.23/build/index.module.js",
					"three-mesh-bvh": "https://cdn.jsdelivr.net/npm/three-mesh-bvh@0.7.4/build/index.module.js"
				}
			}
		</script>

		<script src="/examples/jsm/libs/draco/gltf/draco_decoder.js"></script>

		<link rel="stylesheet" href="js/libs/codemirror/codemirror.css">
		<link rel="stylesheet" href="js/libs/codemirror/theme/monokai.css">
		<script src="js/libs/codemirror/codemirror.js"></script>
		<script src="js/libs/codemirror/mode/javascript.js"></script>
		<script src="js/libs/codemirror/mode/glsl.js"></script>

		<script src="js/libs/esprima.js"></script>
		<script src="js/libs/jsonlint.js"></script>

		<script src="https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.11.6/dist/ffmpeg.min.js"></script>

		<link rel="stylesheet" href="js/libs/codemirror/addon/dialog.css">
		<link rel="stylesheet" href="js/libs/codemirror/addon/show-hint.css">
		<link rel="stylesheet" href="js/libs/codemirror/addon/tern.css">

		<script src="js/libs/codemirror/addon/dialog.js"></script>
		<script src="js/libs/codemirror/addon/show-hint.js"></script>
		<script src="js/libs/codemirror/addon/tern.js"></script>
		<script src="js/libs/acorn/acorn.js"></script>
		<script src="js/libs/acorn/acorn_loose.js"></script>
		<script src="js/libs/acorn/walk.js"></script>
		<script src="js/libs/ternjs/polyfill.js"></script>
		<script src="js/libs/ternjs/signal.js"></script>
		<script src="js/libs/ternjs/tern.js"></script>
		<script src="js/libs/ternjs/def.js"></script>
		<script src="js/libs/ternjs/comment.js"></script>
		<script src="js/libs/ternjs/infer.js"></script>
		<script src="js/libs/ternjs/doc_comment.js"></script>
		<script src="js/libs/tern-threejs/threejs.js"></script>
		<script src="js/libs/signals.min.js"></script>

		<script type="module">

			import * as THREE from 'three';

			import { Editor } from './js/Editor.js';
			import { Viewport } from './js/Viewport.js';
			import { Toolbar } from './js/Toolbar.js';
			import { Script } from './js/Script.js';
			import { Player } from './js/Player.js';
			import { Sidebar } from './js/Sidebar.js';
			import { Menubar } from './js/Menubar.js';
			import { Resizer } from './js/Resizer.js';

			window.URL = window.URL || window.webkitURL;
			window.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;

			//

			const editor = new Editor();

			window.editor = editor; // Expose editor to Console
			window.THREE = THREE; // Expose THREE to APP Scripts and Console

			const viewport = new Viewport( editor );
			document.body.appendChild( viewport.dom );

			const toolbar = new Toolbar( editor );
			document.body.appendChild( toolbar.dom );

			const script = new Script( editor );
			document.body.appendChild( script.dom );

			const player = new Player( editor );
			document.body.appendChild( player.dom );

			const sidebar = new Sidebar( editor );
			document.body.appendChild( sidebar.dom );

			const menubar = new Menubar( editor );
			document.body.appendChild( menubar.dom );

			const resizer = new Resizer( editor );
			document.body.appendChild( resizer.dom );

			// Helper: frame camera to scene or object with a tight fit
			function frameScene(editor, target) {
				try {
					const THREERef = THREE;
					const box = new THREERef.Box3().setFromObject(target || editor.scene);
					if (!box.isEmpty()) {
						const size = box.getSize(new THREERef.Vector3());
						const center = box.getCenter(new THREERef.Vector3());
						const maxDim = Math.max(size.x, size.y, size.z);
						const distance = maxDim * 1.2 + 0.6; // tighter fit
						editor.camera.position.set(center.x, center.y + maxDim * 0.5, center.z + distance);
						editor.camera.lookAt(center);
						if (editor.signals && editor.signals.cameraChanged) editor.signals.cameraChanged.dispatch();
						if (editor.signals && editor.signals.sceneGraphChanged) editor.signals.sceneGraphChanged.dispatch();
					}
				} catch {}
			}

			// Enhanced video controls overlay – anchored to selected video card bottom
			const controls = document.createElement('div');
			controls.style.cssText = 'position:absolute;left:0;top:0;display:none;gap:8px;align-items:center;background:#0b0b0de0;border:1px solid #1f2937;border-radius:10px;padding:8px 12px;color:#e5e7eb;font:12px system-ui;z-index:1000;box-shadow:0 6px 24px rgba(0,0,0,.5);backdrop-filter:blur(8px)';
			const playBtn = document.createElement('button');
			playBtn.textContent = '▶️';
			playBtn.style.cssText = 'background:#111827;color:#e5e7eb;border:1px solid #374151;border-radius:6px;padding:6px 12px;cursor:pointer;transition:all 0.2s;font-size:14px';
			playBtn.addEventListener('mouseenter', () => playBtn.style.background = '#1f2937');
			playBtn.addEventListener('mouseleave', () => playBtn.style.background = '#111827');
			
			const muteBtn = document.createElement('button');
			muteBtn.textContent = '🔊';
			muteBtn.style.cssText = playBtn.style.cssText;
			muteBtn.addEventListener('mouseenter', () => muteBtn.style.background = '#1f2937');
			muteBtn.addEventListener('mouseleave', () => muteBtn.style.background = '#111827');
			
			const timeLabel = document.createElement('span');
			timeLabel.textContent = '0:00 / 0:00';
			timeLabel.style.cssText = 'min-width:80px;text-align:center;font-family:monospace';
			
			const seek = document.createElement('input');
			seek.type = 'range';
			seek.min = '0';
			seek.max = '0';
			seek.step = '0.01';
			seek.style.cssText = 'width:280px;height:6px;background:#374151;border-radius:3px;outline:none;cursor:pointer';
			
			controls.appendChild(playBtn);
			controls.appendChild(muteBtn);
			controls.appendChild(seek);
			controls.appendChild(timeLabel);
			document.body.appendChild(controls);

			let boundVideo = null;
			let boundMesh = null;
			const videoMap = new Map(); // uuid -> HTMLVideoElement
			function fmtTime(t){ if(!isFinite(t)) return '0:00'; const m=Math.floor(t/60); const s=Math.floor(t%60); return m+':' + String(s).padStart(2,'0'); }
			function bindVideoForControls(mesh){
				boundMesh = null;
				boundVideo = null;
				if(!mesh){ 
					controls.style.display='none'; 
					console.log('No mesh selected, hiding controls');
					return; 
				}
				const v = videoMap.get(mesh.uuid);
				if(!v){ 
					controls.style.display='none'; 
					console.log('No video found for mesh:', mesh.uuid);
					return; 
				}
				boundMesh = mesh; 
				boundVideo = v; 
				controls.style.display='flex';
				console.log('Video controls bound to:', mesh.name, 'playing:', !v.paused);
				
				seek.max = isFinite(boundVideo.duration) ? String(boundVideo.duration) : '0';
				seek.value = String(boundVideo.currentTime || 0);
				timeLabel.textContent = `${fmtTime(boundVideo.currentTime||0)} / ${fmtTime(boundVideo.duration||0)}`;
				playBtn.textContent = boundVideo.paused ? '▶️' : '⏸️';
				muteBtn.textContent = boundVideo.muted ? '🔇' : '🔊';
				updateControlsPosition();
			}
			function updateControlsPosition(){
				if(!boundMesh){ return; }
				try{
					const box = new THREE.Box3().setFromObject(boundMesh);
					const size = box.getSize(new THREE.Vector3());
					const center = box.getCenter(new THREE.Vector3());
					const bottom = new THREE.Vector3(center.x, box.min.y, center.z);
					bottom.project(editor.camera);
					const vp = viewport.dom.getBoundingClientRect();
					const x = (bottom.x * 0.5 + 0.5) * vp.width + vp.left;
					const y = ( -bottom.y * 0.5 + 0.5) * vp.height + vp.top;
					// Place controls slightly below bottom edge
					controls.style.left = Math.round(x - controls.offsetWidth/2) + 'px';
					controls.style.top = Math.round(y + 8) + 'px';
				}catch{}
			}
			playBtn.onclick = ()=>{ 
				if(!boundVideo) return; 
				console.log('Play button clicked, video paused:', boundVideo.paused);
				if(boundVideo.paused){ 
					boundVideo.play().then(() => {
						console.log('Video play succeeded');
						playBtn.textContent = '⏸️';
					}).catch((error) => {
						console.error('Video play failed:', error);
					}); 
				} else { 
					boundVideo.pause(); 
					console.log('Video paused');
					playBtn.textContent = '▶️';
				} 
			};
			muteBtn.onclick = ()=>{ 
				if(!boundVideo) return; 
				boundVideo.muted = !boundVideo.muted; 
				muteBtn.textContent = boundVideo.muted ? '🔇' : '🔊'; 
			};
			seek.oninput = ()=>{ 
				if(!boundVideo) return; 
				try{ 
					const newTime = parseFloat(seek.value);
					console.log('Seeking to:', newTime);
					boundVideo.currentTime = newTime; 
				}catch(error) {
					console.error('Seek failed:', error);
				} 
			};
			function tick(){
				if(boundVideo){
					seek.max = isFinite(boundVideo.duration)? String(boundVideo.duration) : seek.max;
					seek.value = String(boundVideo.currentTime||0);
					timeLabel.textContent = `${fmtTime(boundVideo.currentTime||0)} / ${fmtTime(boundVideo.duration||0)}`;
					updateControlsPosition();
				}
				requestAnimationFrame(tick);
			}
			requestAnimationFrame(tick);
			window.addEventListener('resize', updateControlsPosition);

			// Helper: create/update a simple frame behind a mesh; marked to ignore save
			function ensureFrameForMesh(mesh, editor, pad = 0.06) {
				try {
					// Try to find an existing frame linked to this mesh
					let frame = null;
					if (editor.scene) {
						editor.scene.traverse(obj => {
							if (obj !== mesh && obj.isMesh && obj.userData && obj.userData.ignoreSave && obj.userData.parentUuid === mesh.uuid) frame = obj;
						});
					}
					if (!frame) {
						frame = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), new THREE.MeshBasicMaterial({ color: 0x111111, side: THREE.DoubleSide }));
						frame.name = 'VideoFrame';
						frame.userData = { ignoreSave: true, parentUuid: mesh.uuid };
						editor.addObject(frame);
					}
					frame.position.copy(mesh.position);
					frame.rotation.copy(mesh.rotation);
					frame.scale.set(Math.max(mesh.scale.x + pad, 0.01), Math.max(mesh.scale.y + pad, 0.01), 1);
					frame.renderOrder = (mesh.renderOrder || 0) - 1;
				} catch {}
			}

			//

		// Add timeout and error handling for storage initialization
		let initTimeout = setTimeout(() => {
			console.error('Editor storage initialization timed out, proceeding anyway');
			initializeEditor();
		}, 5000);

		function initializeEditor() {
			clearTimeout(initTimeout);

			// Add sample scene objects immediately
			// Scene will be loaded from space data via postMessage

			// Clear any cached scene data
			editor.clear();

			console.log('Three.js Editor initialized successfully');
			try { window.parent.postMessage({ type: 'ready' }, '*'); } catch (e) {}
		}

		try {
			editor.storage.init( function () {
				clearTimeout(initTimeout);

				editor.storage.get( async function ( state ) {

					if ( isLoadingFromHash ) return;

					if ( state !== undefined ) {

						await editor.fromJSON( state );

					}

					const selected = editor.config.getKey( 'selected' );

					if ( selected !== undefined ) {

						editor.selectByUuid( selected );

					}

					initializeEditor();
				} );
			} );
		} catch (error) {
			console.error('Storage initialization failed:', error);
			initializeEditor();
		}

		//

		let timeout;

		function saveState() {

			if ( editor.config.getKey( 'autosave' ) === false ) {

				return;

			}

			clearTimeout( timeout );

			timeout = setTimeout( function () {

				editor.signals.savingStarted.dispatch();

				timeout = setTimeout( function () {

					// Use safe serialization that skips VideoTexture maps
					editor.storage.set( safeEditorToJSON(editor) );

					editor.signals.savingFinished.dispatch();

				}, 100 );

			}, 1000 );

		}

		// Safely serialize the scene by temporarily removing video material maps
		function safeEditorToJSON(editor){
			const removedMaps = [];
			try {
				editor.scene.traverse((obj)=>{
					try {
						if (obj && obj.isMesh && obj.material && obj.material.map) {
							const isVideoMesh = obj.userData?.assetType === 'video' || /VideoFrame/i.test(obj.name||'');
							if (isVideoMesh) {
								removedMaps.push({ material: obj.material, map: obj.material.map });
								obj.material.map = null;
								obj.material.needsUpdate = true;
							}
						}
					} catch {}
				});
				return editor.toJSON();
			} finally {
				// Restore maps
				for (const { material, map } of removedMaps) {
					try {
						material.map = map;
						material.needsUpdate = true;
					} catch {}
				}
			}
		}

		const signals = editor.signals;

		signals.geometryChanged.add( saveState );
		signals.objectAdded.add( saveState );
		signals.objectChanged.add( saveState );
		signals.objectRemoved.add( saveState );
		signals.materialChanged.add( saveState );
		signals.sceneBackgroundChanged.add( saveState );
		signals.sceneEnvironmentChanged.add( saveState );
		signals.sceneFogChanged.add( saveState );
		signals.sceneGraphChanged.add( saveState );
		signals.scriptChanged.add( saveState );
		signals.historyChanged.add( saveState );

		// Bridge: forward updates to parent
		function send(msg) { try { window.parent.postMessage(msg, '*'); } catch (e) {} }
		signals.objectSelected.add(function(object){
			send({ type: 'selection_changed', data: { selectedObjects: object ? [object.uuid] : [] } });
		});
		signals.objectAdded.add(function(object){ send({ type: 'object_added', data: { uuid: object.uuid } }); });
		signals.objectRemoved.add(function(object){ send({ type: 'object_removed', data: { uuid: object.uuid } }); });
		signals.objectChanged.add(function(object){ send({ type: 'object_transformed', data: { uuid: object.uuid } }); });

		// Listen for commands from parent
		window.addEventListener('message', function(event) {
			// Filter out metamask and other extension messages
			if (!event.data || typeof event.data !== 'object' || event.data.target) return;

			const command = event.data;
			console.log('Three.js Editor received command:', command);

			switch (command.type) {
							case 'load_scene':
				// Clear current scene first
				editor.clear();
				console.log('Cleared scene, loading new data...');

				// Try to use ObjectLoader first for proper Three.js scene loading
				if (command.data && command.data.metadata && command.data.object) {
					try {
						console.log('Loading scene with ObjectLoader, textures:', command.data.textures?.length || 0, 'images:', command.data.images?.length || 0);
						
						const loader = new THREE.ObjectLoader();
						const loadedObject = loader.parse(command.data);
						
						// Post-process loaded objects to ensure textures are applied
						loadedObject.traverse((child) => {
							if (!child.isMesh) return;
							console.log('Processing mesh:', child.name, 'position:', child.position, 'userData:', child.userData);

							// Ensure correct geometry for media assets (force plane for image/video)
							const at = (child.userData && child.userData.assetType) || '';
							if ((at === 'image' || at === 'video') && !(child.geometry && child.geometry.isPlaneGeometry)) {
								child.geometry = new THREE.PlaneGeometry(1, 1);
							}

							// Re-apply saved transform defensively before media attaches
							if (Array.isArray(child.position)) child.position.fromArray(child.position);
							if (Array.isArray(child.rotation)) child.rotation.fromArray(child.rotation);
							if (Array.isArray(child.scale)) child.scale.fromArray(child.scale);

							const url = child.userData && child.userData.mediaUrl;
							if (!url) {
								console.log('Mesh has no mediaUrl:', child.name);
								return;
							}

							applyMediaToMesh(child, url, child.userData.assetType, editor);
						});
						
						editor.scene.add(loadedObject);
						frameScene(editor, loadedObject);
						// Reframe after first render tick to ensure bounds are final
						requestAnimationFrame(()=> frameScene(editor, loadedObject));
						
						// Update the editor
						editor.signals.sceneGraphChanged.dispatch();
						editor.signals.objectSelected.dispatch(null);
						
						console.log(`Scene loaded successfully with ${loadedObject.children.length} objects`);
						
						// Hook selection to show controls for videos
						try {
							editor.signals.objectSelected.add(function(object){
								console.log('Object selected:', object?.name, object?.uuid);
								if (object && videoMap.has(object.uuid)) {
									console.log('Binding video controls for:', object.name);
									bindVideoForControls(object);
								} else {
									bindVideoForControls(null);
								}
							});
						} catch (error) {
							console.error('Failed to bind video controls:', error);
						}
						
						// Send success response
						send({
							type: 'scene_loaded',
							data: { success: true, objectCount: loadedObject.children.length },
							commandId: command.id
						});
						
					} catch (error) {
						console.error('ObjectLoader failed, falling back to manual creation:', error);
						// Fall back to manual object creation
						loadSceneManually(command, editor, send);
					}
				} else if (command.data && command.data.object && command.data.object.children) {
					// Manual object creation for simpler scene data
					loadSceneManually(command, editor, send);
				} else {
					console.log('No scene data or children found, scene remains empty');
					// Send success response even for empty scene
					send({
						type: 'scene_loaded',
						data: { success: true, objectCount: 0 },
						commandId: command.id
					});
				}
				break;

				case 'clear_scene':
					editor.clear();
					console.log('Scene cleared');
					break;

				case 'add_object':
					try {
						const objData = command.data;
						let geometry, material;

						// Create geometry
						switch (objData.geometry.type) {
							case 'BoxGeometry':
								geometry = new THREE.BoxGeometry(
									objData.geometry.width || 1,
									objData.geometry.height || 1,
									objData.geometry.depth || 1
								);
								break;
							case 'SphereGeometry':
								geometry = new THREE.SphereGeometry(objData.geometry.radius || 0.5);
								break;
							case 'PlaneGeometry':
								geometry = new THREE.PlaneGeometry(
									objData.geometry.width || 1,
									objData.geometry.height || 1
								);
								break;
							default:
								geometry = new THREE.BoxGeometry(1, 1, 1);
						}

						// Neutral base color; texture/video will set to white
						material = new THREE.MeshBasicMaterial({ color: 0x999999, side: THREE.DoubleSide });

						// Create mesh
						const mesh = new THREE.Mesh(geometry, material);
						mesh.name = objData.name || 'Object';
						mesh.position.fromArray(objData.position || [0, 0, 0]);
						if (objData.rotation) mesh.rotation.fromArray(objData.rotation);
						if (objData.scale) mesh.scale.fromArray(objData.scale);
						mesh.userData = objData.userData || {};
						editor.addObject(mesh);

						// Apply media if provided (image/video), same as load path
						if (objData.userData && objData.userData.mediaUrl) {
							console.log('Loading media for add_object:', objData.userData.mediaUrl);
							applyMediaToMesh(mesh, objData.userData.mediaUrl, objData.userData.assetType, editor);
						}

						console.log('Added object:', mesh.name);
						// Send success response
						send({ 
							type: 'object_added_success', 
							data: { success: true, uuid: mesh.uuid, name: mesh.name },
							commandId: command.id 
						});
					} catch (error) {
						console.error('Failed to add object:', error);
						send({ type: 'error', data: { error: 'Failed to add object: ' + error.message } });
					}
					break;

				case 'export_scene':
					try {
						console.log('Exporting scene...');
						// Temporarily remove helper frames (ignoreSave) from the live scene, then restore
						const removed = [];
						editor.scene.traverse((obj) => {
							if (obj.userData && obj.userData.ignoreSave && obj.parent) {
								removed.push({ obj, parent: obj.parent });
							}
						});
						removed.forEach(({ obj, parent }) => { try { parent.remove(obj); } catch {} });
						const sceneJSON = editor.scene.toJSON();
						removed.forEach(({ obj, parent }) => { try { parent.add(obj); } catch {} });
						console.log('Scene JSON:', sceneJSON);
						send({
							type: 'scene_exported',
							data: sceneJSON,
							commandId: command.id
						});
						console.log('Scene exported successfully');
					} catch (error) {
						console.error('Failed to export scene:', error);
						send({ type: 'error', data: { error: 'Failed to export scene: ' + error.message } });
					}
					break;
			}
		});

			//

			document.addEventListener( 'dragover', function ( event ) {

				event.preventDefault();
				event.dataTransfer.dropEffect = 'copy';

			} );

			document.addEventListener( 'drop', function ( event ) {

				event.preventDefault();

				if ( event.dataTransfer.types[ 0 ] === 'text/plain' ) return; // Outliner drop

				if ( event.dataTransfer.items ) {

					// DataTransferItemList supports folders

					editor.loader.loadItemList( event.dataTransfer.items );

				} else {

					editor.loader.loadFiles( event.dataTransfer.files );

				}

			} );

			// Manual scene loading function for fallback
			function loadSceneManually(command, editor, send) {
				try {
					command.data.object.children.forEach(child => {
						// Create basic geometry based on asset type
						let geometry, material;
						const assetType = child.userData?.assetType || 'unknown';

						switch (assetType) {
							case 'image':
							case 'video':
							case 'layout_reference':
							case 'layout':
								geometry = new THREE.PlaneGeometry(2, 2);
								// Support textured planes when mediaUrl is provided
								const url = child.userData && child.userData.mediaUrl;
								if (url) {
									console.log('Loading texture from userData.mediaUrl:', url);
									const textureLoader = new THREE.TextureLoader();
									textureLoader.crossOrigin = 'anonymous';
									// Create initial material
									material = new THREE.MeshBasicMaterial({
										color: assetType === 'image' ? 0x4f46e5 :
											   assetType === 'video' ? 0xef4444 : 0x8b5cf6,
										transparent: true,
										opacity: 0.9
									});
									
									// Load texture asynchronously and update material
									textureLoader.load(
										url,
										(texture) => {
											texture.colorSpace = THREE.SRGBColorSpace;
											texture.needsUpdate = true;
											material.map = texture;
											material.needsUpdate = true;
											console.log('Texture loaded successfully for load_scene:', child.name);
										},
										undefined,
										(error) => {
											console.warn('Failed to load texture for load_scene:', url, error);
										}
									);
								} else {
									material = new THREE.MeshBasicMaterial({
										color: assetType === 'image' ? 0x4f46e5 :
											   assetType === 'video' ? 0xef4444 : 0x8b5cf6,
										transparent: true,
										opacity: 0.9
									});
								}
								break;
							case 'audio':
								geometry = new THREE.SphereGeometry(0.5);
								material = new THREE.MeshBasicMaterial({ color: 0x10b981 });
								break;
							case 'text':
								geometry = new THREE.BoxGeometry(1, 0.5, 0.1);
								material = new THREE.MeshBasicMaterial({ color: 0xf59e0b });
								break;
							default:
								geometry = new THREE.BoxGeometry(1, 1, 1);
								material = new THREE.MeshBasicMaterial({ color: 0x6b7280 });
						}

						const mesh = new THREE.Mesh(geometry, material);
						mesh.name = child.name || child.userData?.assetId || 'Unknown';
						mesh.uuid = child.uuid;
						mesh.position.fromArray(child.position);
						mesh.rotation.fromArray(child.rotation);
						mesh.scale.fromArray(child.scale);
						mesh.userData = child.userData || {};

						editor.addObject(mesh);
					});
					console.log('Scene loaded manually with', command.data.object.children.length, 'objects');
					// Send success response
					send({
						type: 'scene_loaded',
						data: { success: true, objectCount: command.data.object.children.length },
						commandId: command.id
					});
				} catch (error) {
					console.error('Failed to load scene manually:', error);
					send({ type: 'error', data: { error: 'Failed to load scene: ' + error.message } });
				}
			}

						// Shared helper to apply image/video media to a mesh consistently
			function applyMediaToMesh(mesh, url, assetType, editor) {
				if (!url) return;
				const isVideo = (assetType === 'video') || /\.mp4(\?|$)/i.test(url);
				if (isVideo) {
					// Create video element and add to DOM for loading
					const video = document.createElement('video');
					video.src = url;
					video.crossOrigin = 'anonymous';
					video.muted = true;
					video.loop = true;
					video.playsInline = true;
					video.preload = 'auto';
					video.style.display = 'none'; // Hide but keep in DOM
					document.body.appendChild(video); // Required for loading
					
					console.log('Loading video:', url);
					
					let textureCreated = false; // Prevent multiple texture creation
					
					// Debug all video events
					video.addEventListener('loadstart', () => console.log('Video loadstart'));
					video.addEventListener('loadedmetadata', () => console.log('Video loadedmetadata'));
					video.addEventListener('canplay', () => console.log('Video canplay'));
					video.addEventListener('canplaythrough', () => {
						if (textureCreated) {
							console.log('Video canplaythrough - texture already created, skipping');
							return;
						}
						
						console.log('Video canplaythrough - creating texture');
						textureCreated = true;
						
						const videoTexture = new THREE.VideoTexture(video);
						videoTexture.colorSpace = THREE.SRGBColorSpace;
						// Fix sRGB texture format requirements for video too
						videoTexture.format = THREE.RGBAFormat;
						videoTexture.type = THREE.UnsignedByteType;
						videoTexture.generateMipmaps = false;
						videoTexture.minFilter = THREE.LinearFilter;
						videoTexture.magFilter = THREE.LinearFilter;
						videoTexture.wrapS = THREE.ClampToEdgeWrapping;
						videoTexture.wrapT = THREE.ClampToEdgeWrapping;
						videoTexture.flipY = false;
						
						// Apply to mesh with a fresh unlit material
						if (mesh.material) {
							try { mesh.material.dispose && mesh.material.dispose(); } catch {}
						}
						mesh.material = new THREE.MeshBasicMaterial({
							map: videoTexture,
							side: THREE.DoubleSide,
							transparent: false,
							toneMapped: false
						});
						mesh.material.needsUpdate = true;
						
						// Set aspect ratio
						const aspectRatio = video.videoWidth / video.videoHeight;
						if (aspectRatio > 0 && isFinite(aspectRatio)) {
							mesh.scale.set(aspectRatio * 2, 2, 1);
						}
						
						// Only update texture when video has complete frames
						const startUpdates = () => {
							const update = () => {
								// Only update if video is playing AND has sufficient data AND dimensions are known
								if (!video.paused && !video.ended && 
									video.readyState >= 3 && // HAVE_FUTURE_DATA - can play without buffering
									video.videoWidth > 0 && video.videoHeight > 0) {
									videoTexture.needsUpdate = true;
								}
								if (video.requestVideoFrameCallback) {
									video.requestVideoFrameCallback(update);
								} else {
									requestAnimationFrame(update);
								}
							};
							if (video.requestVideoFrameCallback) {
								video.requestVideoFrameCallback(update);
							} else {
								requestAnimationFrame(update);
							}
						};
						
						// Wait for video to be fully ready before starting updates
						video.play().then(() => {
							// Only set initial needsUpdate if video dimensions are known
							if (video.videoWidth > 0 && video.videoHeight > 0) {
								videoTexture.needsUpdate = true;
							}
							startUpdates();
						}).catch(() => { startUpdates(); });
						
						if (editor.signals) {
							editor.signals.materialChanged?.dispatch(mesh.material);
							editor.signals.sceneGraphChanged?.dispatch();
						}
						ensureFrameForMesh(mesh, editor);
					});
					
					video.addEventListener('error', (e) => {
						console.error('Video loading error:', e, video.error);
					});
					
					// Track video element
					videoMap.set(mesh.uuid, video);
					console.log('Video mapped for mesh:', mesh.uuid, mesh.name);
				} else {
					const textureLoader = new THREE.TextureLoader();
					textureLoader.crossOrigin = 'anonymous';
					textureLoader.load(
						url,
						(texture) => {
							// Wait for image to be fully loaded before applying texture
							if (texture.image && texture.image.complete && texture.image.naturalWidth > 0) {
								texture.colorSpace = THREE.SRGBColorSpace;
								texture.format = THREE.RGBAFormat;
								texture.type = THREE.UnsignedByteType;
								texture.generateMipmaps = false;
								texture.minFilter = THREE.LinearFilter;
								texture.magFilter = THREE.LinearFilter;
								texture.wrapS = THREE.ClampToEdgeWrapping;
								texture.wrapT = THREE.ClampToEdgeWrapping;
								texture.flipY = false;
								
								if (!mesh.material || !(mesh.material instanceof THREE.MeshBasicMaterial)) {
									mesh.material = new THREE.MeshBasicMaterial({ side: THREE.DoubleSide, toneMapped: false });
								}
								mesh.material.color && mesh.material.color.set(0xffffff);
								mesh.material.map = texture;
								mesh.material.needsUpdate = true;
							} else {
								// Image not ready, wait for it
								const checkReady = () => {
									if (texture.image && texture.image.complete && texture.image.naturalWidth > 0) {
										texture.needsUpdate = true;
										if (!mesh.material || !(mesh.material instanceof THREE.MeshBasicMaterial)) {
											mesh.material = new THREE.MeshBasicMaterial({ side: THREE.DoubleSide, toneMapped: false });
										}
										mesh.material.map = texture;
										mesh.material.needsUpdate = true;
									} else {
										requestAnimationFrame(checkReady);
									}
								};
								checkReady();
							}
							if (editor.signals && editor.signals.materialChanged) {
								editor.signals.materialChanged.dispatch(mesh.material);
							}
							if (editor.signals && editor.signals.sceneGraphChanged) {
								editor.signals.sceneGraphChanged.dispatch();
							}
							ensureFrameForMesh(mesh, editor);
						},
						undefined,
						(error) => {
							console.error('Error loading texture for mesh:', mesh.name, error);
						}
					);
				}
			}

			function onWindowResize() {

				editor.signals.windowResize.dispatch();

			}

			window.addEventListener( 'resize', onWindowResize );

			onWindowResize();

			//

			let isLoadingFromHash = false;
			const hash = window.location.hash;

			if ( hash.slice( 1, 6 ) === 'file=' ) {

				const file = hash.slice( 6 );

				if ( confirm( editor.strings.getKey( 'prompt/file/open' ) ) ) {

					const loader = new THREE.FileLoader();
					loader.crossOrigin = '';
					loader.load( file, function ( text ) {

						editor.clear();
						editor.fromJSON( JSON.parse( text ) );

					} );

					isLoadingFromHash = true;

				}

			}

			// ServiceWorker

			if ( 'serviceWorker' in navigator ) {

				try {

					navigator.serviceWorker.register( 'sw.js' );

				} catch ( error ) {

				}

			}

		</script>
	</body>
</html>

// Redeploy marker: loader unchanged; textures only
