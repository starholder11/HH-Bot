<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js editor</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link rel="apple-touch-icon" href="images/icon.png">
		<link rel="manifest" href="manifest.json">
		<link rel="shortcut icon" href="/favicon.ico" />
	</head>
	<body>
		<link rel="stylesheet" href="css/main.css">

		<script type="importmap">
			{
				"imports": {
					"three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js",
					"three/addons/": "/examples/jsm/",
					"three/examples/": "/examples/",
					"three-gpu-pathtracer": "https://cdn.jsdelivr.net/npm/three-gpu-pathtracer@0.0.23/build/index.module.js",
					"three-mesh-bvh": "https://cdn.jsdelivr.net/npm/three-mesh-bvh@0.7.4/build/index.module.js"
				}
			}
		</script>

		<script src="/examples/jsm/libs/draco/gltf/draco_decoder.js"></script>

		<link rel="stylesheet" href="js/libs/codemirror/codemirror.css">
		<link rel="stylesheet" href="js/libs/codemirror/theme/monokai.css">
		<script src="js/libs/codemirror/codemirror.js"></script>
		<script src="js/libs/codemirror/mode/javascript.js"></script>
		<script src="js/libs/codemirror/mode/glsl.js"></script>

		<script src="js/libs/esprima.js"></script>
		<script src="js/libs/jsonlint.js"></script>

		<script src="https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.11.6/dist/ffmpeg.min.js"></script>

		<link rel="stylesheet" href="js/libs/codemirror/addon/dialog.css">
		<link rel="stylesheet" href="js/libs/codemirror/addon/show-hint.css">
		<link rel="stylesheet" href="js/libs/codemirror/addon/tern.css">

		<script src="js/libs/codemirror/addon/dialog.js"></script>
		<script src="js/libs/codemirror/addon/show-hint.js"></script>
		<script src="js/libs/codemirror/addon/tern.js"></script>
		<script src="js/libs/acorn/acorn.js"></script>
		<script src="js/libs/acorn/acorn_loose.js"></script>
		<script src="js/libs/acorn/walk.js"></script>
		<script src="js/libs/ternjs/polyfill.js"></script>
		<script src="js/libs/ternjs/signal.js"></script>
		<script src="js/libs/ternjs/tern.js"></script>
		<script src="js/libs/ternjs/def.js"></script>
		<script src="js/libs/ternjs/comment.js"></script>
		<script src="js/libs/ternjs/infer.js"></script>
		<script src="js/libs/ternjs/doc_comment.js"></script>
		<script src="js/libs/tern-threejs/threejs.js"></script>
		<script src="js/libs/signals.min.js"></script>

		<script type="module">

			import * as THREE from 'three';

			import { Editor } from './js/Editor.js';
			import { Viewport } from './js/Viewport.js';
			import { Toolbar } from './js/Toolbar.js';
			import { Script } from './js/Script.js';
			import { Player } from './js/Player.js';
			import { Sidebar } from './js/Sidebar.js';
			import { Menubar } from './js/Menubar.js';
			import { Resizer } from './js/Resizer.js';

			window.URL = window.URL || window.webkitURL;
			window.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;

			//

			const editor = new Editor();

			window.editor = editor; // Expose editor to Console
			window.THREE = THREE; // Expose THREE to APP Scripts and Console

			const viewport = new Viewport( editor );
			document.body.appendChild( viewport.dom );

			const toolbar = new Toolbar( editor );
			document.body.appendChild( toolbar.dom );

			const script = new Script( editor );
			document.body.appendChild( script.dom );

			const player = new Player( editor );
			document.body.appendChild( player.dom );

			const sidebar = new Sidebar( editor );
			document.body.appendChild( sidebar.dom );

			const menubar = new Menubar( editor );
			document.body.appendChild( menubar.dom );

			const resizer = new Resizer( editor );
			document.body.appendChild( resizer.dom );

			// Helper: frame camera to scene or object with a tight fit
			function frameScene(editor, target) {
				try {
					const THREERef = THREE;
					const box = new THREERef.Box3().setFromObject(target || editor.scene);
					if (!box.isEmpty()) {
						const size = box.getSize(new THREERef.Vector3());
						const center = box.getCenter(new THREERef.Vector3());
						const maxDim = Math.max(size.x, size.y, size.z);
						const distance = maxDim * 1.2 + 0.6; // tighter fit
						editor.camera.position.set(center.x, center.y + maxDim * 0.5, center.z + distance);
						editor.camera.lookAt(center);
						if (editor.signals && editor.signals.cameraChanged) editor.signals.cameraChanged.dispatch();
						if (editor.signals && editor.signals.sceneGraphChanged) editor.signals.sceneGraphChanged.dispatch();
					}
				} catch {}
			}

			// Enhanced video controls overlay â€“ anchored to selected video card bottom
			const controls = document.createElement('div');
			controls.style.cssText = 'position:absolute;left:0;top:0;display:none;gap:8px;align-items:center;background:#0b0b0de0;border:1px solid #1f2937;border-radius:10px;padding:8px 12px;color:#e5e7eb;font:12px system-ui;z-index:1000;box-shadow:0 6px 24px rgba(0,0,0,.5);backdrop-filter:blur(8px)';
			const playBtn = document.createElement('button');
			playBtn.textContent = 'â–¶ï¸';
			playBtn.style.cssText = 'background:#111827;color:#e5e7eb;border:1px solid #374151;border-radius:6px;padding:6px 12px;cursor:pointer;transition:all 0.2s;font-size:14px';
			playBtn.addEventListener('mouseenter', () => playBtn.style.background = '#1f2937');
			playBtn.addEventListener('mouseleave', () => playBtn.style.background = '#111827');

			const muteBtn = document.createElement('button');
			muteBtn.textContent = 'ðŸ”Š';
			muteBtn.style.cssText = playBtn.style.cssText;
			muteBtn.addEventListener('mouseenter', () => muteBtn.style.background = '#1f2937');
			muteBtn.addEventListener('mouseleave', () => muteBtn.style.background = '#111827');

			const timeLabel = document.createElement('span');
			timeLabel.textContent = '0:00 / 0:00';
			timeLabel.style.cssText = 'min-width:80px;text-align:center;font-family:monospace';

			const seek = document.createElement('input');
			seek.type = 'range';
			seek.min = '0';
			seek.max = '0';
			seek.step = '0.01';
			seek.style.cssText = 'width:280px;height:6px;background:#374151;border-radius:3px;outline:none;cursor:pointer';

			controls.appendChild(playBtn);
			controls.appendChild(muteBtn);
			controls.appendChild(seek);
			controls.appendChild(timeLabel);
			document.body.appendChild(controls);

			let boundVideo = null;
			let boundMesh = null;
			const videoMap = new Map(); // uuid -> HTMLVideoElement
			function fmtTime(t){ if(!isFinite(t)) return '0:00'; const m=Math.floor(t/60); const s=Math.floor(t%60); return m+':' + String(s).padStart(2,'0'); }
			function bindVideoForControls(mesh){
				boundMesh = null;
				boundVideo = null;
				if(!mesh){
					controls.style.display='none';
					console.log('No mesh selected, hiding controls');
					return;
				}
				const v = videoMap.get(mesh.uuid);
				if(!v){
					controls.style.display='none';
					console.log('No video found for mesh:', mesh.uuid);
					return;
				}
				boundMesh = mesh;
				boundVideo = v;
				controls.style.display='flex';
				console.log('Video controls bound to:', mesh.name, 'playing:', !v.paused);

				seek.max = isFinite(boundVideo.duration) ? String(boundVideo.duration) : '0';
				seek.value = String(boundVideo.currentTime || 0);
				timeLabel.textContent = `${fmtTime(boundVideo.currentTime||0)} / ${fmtTime(boundVideo.duration||0)}`;
				playBtn.textContent = boundVideo.paused ? 'â–¶ï¸' : 'â¸ï¸';
				muteBtn.textContent = boundVideo.muted ? 'ðŸ”‡' : 'ðŸ”Š';
				updateControlsPosition();
			}
			function updateControlsPosition(){
				if(!boundMesh){ return; }
				try{
					const box = new THREE.Box3().setFromObject(boundMesh);
					const size = box.getSize(new THREE.Vector3());
					const center = box.getCenter(new THREE.Vector3());
					const bottom = new THREE.Vector3(center.x, box.min.y, center.z);
					bottom.project(editor.camera);
					const vp = viewport.dom.getBoundingClientRect();
					const x = (bottom.x * 0.5 + 0.5) * vp.width + vp.left;
					const y = ( -bottom.y * 0.5 + 0.5) * vp.height + vp.top;
					// Place controls slightly below bottom edge
					controls.style.left = Math.round(x - controls.offsetWidth/2) + 'px';
					controls.style.top = Math.round(y + 8) + 'px';
				}catch{}
			}
			playBtn.onclick = ()=>{
				if(!boundVideo) return;
				console.log('Play button clicked, video paused:', boundVideo.paused);
				if(boundVideo.paused){
					boundVideo.play().then(() => {
						console.log('Video play succeeded');
						playBtn.textContent = 'â¸ï¸';
					}).catch((error) => {
						console.error('Video play failed:', error);
					});
				} else {
					boundVideo.pause();
					console.log('Video paused');
					playBtn.textContent = 'â–¶ï¸';
				}
			};
			muteBtn.onclick = ()=>{
				if(!boundVideo) return;
				boundVideo.muted = !boundVideo.muted;
				muteBtn.textContent = boundVideo.muted ? 'ðŸ”‡' : 'ðŸ”Š';
			};
			seek.oninput = ()=>{
				if(!boundVideo) return;
				try{
					const newTime = parseFloat(seek.value);
					console.log('Seeking to:', newTime);
					boundVideo.currentTime = newTime;
				}catch(error) {
					console.error('Seek failed:', error);
				}
			};
			function tick(){
				if(boundVideo){
					seek.max = isFinite(boundVideo.duration)? String(boundVideo.duration) : seek.max;
					seek.value = String(boundVideo.currentTime||0);
					timeLabel.textContent = `${fmtTime(boundVideo.currentTime||0)} / ${fmtTime(boundVideo.duration||0)}`;
					updateControlsPosition();
				}
				requestAnimationFrame(tick);
			}
			requestAnimationFrame(tick);
			window.addEventListener('resize', updateControlsPosition);

			// Helper: create/update a simple frame behind a mesh; non-selectable and marked to ignore save
			function ensureFrameForMesh(mesh, editor, pad = 0.06) {
				try {
					// Try to find an existing frame linked to this mesh
					let frame = null;
					if (editor.scene) {
						editor.scene.traverse(obj => {
							if (
								obj !== mesh &&
								obj.isMesh &&
								obj.userData &&
								obj.userData.ignoreSave &&
								obj.userData.parentUuid === mesh.uuid
							) frame = obj;
						});
					}
					if (!frame) {
						const mat = new THREE.MeshBasicMaterial({ color: 0x111111, side: THREE.DoubleSide });
						// Ensure the frame never occludes the media (no depth test/write; polygon offset)
						mat.depthTest = false;
						mat.depthWrite = false;
						mat.polygonOffset = true;
						mat.polygonOffsetFactor = 1;
						mat.polygonOffsetUnits = 1;

						frame = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), mat);
						frame.name = '_helper:VideoFrame';
						frame.userData = { ignoreSave: true, parentUuid: mesh.uuid, isHelper: true };
						// Make helper non-selectable by raycaster
						frame.raycast = function(){};
						// Add directly to scene so it doesn't pollute history/selection signals
						editor.scene.add(frame);
					}
					// Match transform and add slight backward offset along mesh normal to avoid coplanar z-fight
					frame.position.copy(mesh.position);
					frame.rotation.copy(mesh.rotation);
					frame.scale.set(Math.max(mesh.scale.x + pad, 0.01), Math.max(mesh.scale.y + pad, 0.01), 1);
					const offset = new THREE.Vector3(0, 0, -0.001).applyQuaternion(mesh.quaternion);
					frame.position.add(offset);
					frame.renderOrder = (mesh.renderOrder || 0) - 1;
				} catch {}
			}

			//

		// Add timeout and error handling for storage initialization
		let initTimeout = setTimeout(() => {
			console.error('Editor storage initialization timed out, proceeding anyway');
			initializeEditor();
		}, 5000);

		function initializeEditor() {
			clearTimeout(initTimeout);

			// Add sample scene objects immediately
			// Scene will be loaded from space data via postMessage

			// Clear any cached scene data
			editor.clear();

			console.log('Three.js Editor initialized successfully');
			try { window.parent.postMessage({ type: 'ready' }, '*'); } catch (e) {}
		}

		try {
			editor.storage.init( function () {
				clearTimeout(initTimeout);

				editor.storage.get( async function ( state ) {

					if ( isLoadingFromHash ) return;

					if ( state !== undefined ) {

						await editor.fromJSON( state );

					}

					const selected = editor.config.getKey( 'selected' );

					if ( selected !== undefined ) {

						editor.selectByUuid( selected );

					}

					initializeEditor();
				} );
			} );
		} catch (error) {
			console.error('Storage initialization failed:', error);
			initializeEditor();
		}

		//

		let timeout;

		function saveState() {

			if ( editor.config.getKey( 'autosave' ) === false ) {

				return;

			}

			clearTimeout( timeout );

			timeout = setTimeout( function () {

				editor.signals.savingStarted.dispatch();

				timeout = setTimeout( function () {

					// Use safe serialization that skips VideoTexture maps
					editor.storage.set( safeEditorToJSON(editor) );

					editor.signals.savingFinished.dispatch();

				}, 100 );

			}, 1000 );

		}

		// Safely serialize the scene by temporarily removing video material maps
		function safeEditorToJSON(editor){
			const removedMaps = [];
			try {
				editor.scene.traverse((obj)=>{
					try {
						if (obj && obj.isMesh && obj.material && obj.material.map) {
							const isVideoMesh = obj.userData?.assetType === 'video' || /VideoFrame/i.test(obj.name||'');
							if (isVideoMesh) {
								removedMaps.push({ material: obj.material, map: obj.material.map });
								obj.material.map = null;
								obj.material.needsUpdate = true;
							}
						}
					} catch {}
				});
				return editor.toJSON();
			} finally {
				// Restore maps
				for (const { material, map } of removedMaps) {
					try {
						material.map = map;
						material.needsUpdate = true;
					} catch {}
				}
			}
		}

		const signals = editor.signals;

		signals.geometryChanged.add( saveState );
		signals.objectAdded.add( saveState );
		signals.objectChanged.add( saveState );
		signals.objectRemoved.add( saveState );
		signals.materialChanged.add( saveState );
		signals.sceneBackgroundChanged.add( saveState );
		signals.sceneEnvironmentChanged.add( saveState );
		signals.sceneFogChanged.add( saveState );
		signals.sceneGraphChanged.add( saveState );
		signals.scriptChanged.add( saveState );
		signals.historyChanged.add( saveState );

		// Bridge: forward updates to parent
		function send(msg) { try { window.parent.postMessage(msg, '*'); } catch (e) {} }
		signals.objectSelected.add(function(object){
			send({ type: 'selection_changed', data: { selectedObjects: object ? [object.uuid] : [] } });
		});
		signals.objectAdded.add(function(object){ send({ type: 'object_added', data: { uuid: object.uuid } }); });
		signals.objectRemoved.add(function(object){ send({ type: 'object_removed', data: { uuid: object.uuid } }); });
		signals.objectChanged.add(function(object){ send({ type: 'object_transformed', data: { uuid: object.uuid } }); });

		// Listen for commands from parent
		window.addEventListener('message', function(event) {
			// Filter out metamask and other extension messages
			if (!event.data || typeof event.data !== 'object' || event.data.target) return;

			const command = event.data;
			console.log('Three.js Editor received command:', command);

			switch (command.type) {
							case 'load_scene':
				// Clear current scene first
				editor.clear();
				console.log('Cleared scene, loading new data...');

				// Use manual scene loading to avoid ObjectLoader texture issues
				if (command.data && command.data.metadata && command.data.object) {
					try {
						console.log('Loading scene manually to avoid ObjectLoader texture issues');

						// Create a new group to hold all objects
						const sceneGroup = new THREE.Group();

						// Process each object manually
						if (command.data.object.children) {
							command.data.object.children.forEach((childData) => {
								if (childData.type === 'Mesh') {
									// Create geometry
									let geometry;
									if (childData.geometry.type === 'PlaneGeometry') {
										geometry = new THREE.PlaneGeometry(1, 1);
									} else {
										geometry = new THREE.PlaneGeometry(1, 1); // Default to plane
									}

									// Create material
									const material = new THREE.MeshBasicMaterial({
										side: THREE.DoubleSide,
										toneMapped: false,
										color: 0xffffff
									});

									// Create mesh
									const mesh = new THREE.Mesh(geometry, material);

									// Set position
									if (childData.position) {
										mesh.position.set(childData.position[0], childData.position[1], childData.position[2]);
									}

									// Set rotation
									if (childData.rotation) {
										mesh.rotation.set(childData.rotation[0], childData.rotation[1], childData.rotation[2]);
									}

									// Set scale
									if (childData.scale) {
										mesh.scale.set(childData.scale[0], childData.scale[1], childData.scale[2]);
									}

									// Copy userData
									if (childData.userData) {
										mesh.userData = { ...childData.userData };
									}

																		// Set name and UUID consistently
									// For layout items, use the layoutItemId as the name for consistency
									if (childData.userData && childData.userData.layoutItemId) {
										mesh.name = childData.userData.layoutItemId;
									} else {
										mesh.name = childData.name || childData.uuid;
									}
									mesh.uuid = childData.uuid;
									
									// Debug: Log UUID assignment
									console.log('Mesh created:', mesh.name, 'UUID:', mesh.uuid);

									// Add to scene group
									sceneGroup.add(mesh);

									// Apply media if it has a mediaUrl
									const url = mesh.userData && mesh.userData.mediaUrl;
									if (url) {
										console.log('Processing mesh:', mesh.name, 'position:', mesh.position, 'userData:', mesh.userData);
										applyMediaToMesh(mesh, url, mesh.userData.assetType, editor);
									} else {
										console.log('Mesh has no mediaUrl:', mesh.name);
									}
								}
							});
						}

						editor.scene.add(sceneGroup);
						frameScene(editor, sceneGroup);
						// Reframe after first render tick to ensure bounds are final
						requestAnimationFrame(()=> frameScene(editor, sceneGroup));

						// Update the editor
						editor.signals.sceneGraphChanged.dispatch();
						editor.signals.objectSelected.dispatch(null);

						console.log(`Scene loaded successfully with ${sceneGroup.children.length} objects`);
						
						// Debug: List all objects and their video mapping status
						sceneGroup.children.forEach((child, index) => {
							console.log(`Object ${index}: name="${child.name}", uuid="${child.uuid}", hasVideo=${videoMap.has(child.uuid)}`);
						});

						// Hook selection to show controls for videos
						try {
							// Clear any existing handlers first
							editor.signals.objectSelected.dispatch = editor.signals.objectSelected.dispatch || function() {};
							
							editor.signals.objectSelected.add(function(object){
								console.log('Object selected:', object?.name, object?.uuid);
								// If a helper frame was selected, resolve to the parent mesh
								if (object && object.userData && object.userData.isHelper && object.userData.parentUuid) {
									let parentMesh = null;
									editor.scene.traverse((o)=>{ if (o.uuid === object.userData.parentUuid) parentMesh = o; });
									if (parentMesh) object = parentMesh;
								}
								console.log('VideoMap has keys:', Array.from(videoMap.keys()));
								console.log('VideoMap has selected UUID?', object ? videoMap.has(object.uuid) : 'no object');
								if (object && videoMap.has(object.uuid)) {
									console.log('Binding video controls for:', object.name);
									bindVideoForControls(object);
								} else {
									console.log('No video found for selected object or no object selected');
									bindVideoForControls(null);
								}
							});
							console.log('Video selection handler bound successfully');
						} catch (error) {
							console.error('Failed to bind video controls:', error);
						}

						// Send success response
						send({
							type: 'scene_loaded',
							data: { success: true, objectCount: sceneGroup.children.length },
							commandId: command.id
						});

					} catch (error) {
						console.error('Manual scene loading failed:', error);
						// Send error response
						send({
							type: 'scene_loaded',
							data: { success: false, error: error.message },
							commandId: command.id
						});
					}
				} else if (command.data && command.data.object && command.data.object.children) {
					// Use the same manual loading approach for simpler scene data
					try {
						console.log('Loading simpler scene data manually');

						// Create a new group to hold all objects
						const sceneGroup = new THREE.Group();

						// Process each object manually
						command.data.object.children.forEach((childData) => {
							if (childData.type === 'Mesh') {
								// Create geometry
								let geometry;
								if (childData.geometry && childData.geometry.type === 'PlaneGeometry') {
									geometry = new THREE.PlaneGeometry(1, 1);
								} else {
									geometry = new THREE.PlaneGeometry(1, 1); // Default to plane
								}

								// Create material
								const material = new THREE.MeshBasicMaterial({
									side: THREE.DoubleSide,
									toneMapped: false,
									color: 0xffffff
								});

								// Create mesh
								const mesh = new THREE.Mesh(geometry, material);

								// Set position
								if (childData.position) {
									mesh.position.set(childData.position[0], childData.position[1], childData.position[2]);
								}

								// Set rotation
								if (childData.rotation) {
									mesh.rotation.set(childData.rotation[0], childData.rotation[1], childData.rotation[2]);
								}

								// Set scale
								if (childData.scale) {
									mesh.scale.set(childData.scale[0], childData.scale[1], childData.scale[2]);
								}

								// Copy userData
								if (childData.userData) {
									mesh.userData = { ...childData.userData };
								}

								// Set name
								mesh.name = childData.name || childData.uuid;
								mesh.uuid = childData.uuid;

								// Add to scene group
								sceneGroup.add(mesh);

								// Apply media if it has a mediaUrl
								const url = mesh.userData && mesh.userData.mediaUrl;
								if (url) {
									console.log('Processing mesh:', mesh.name, 'position:', mesh.position, 'userData:', mesh.userData);
									applyMediaToMesh(mesh, url, mesh.userData.assetType, editor);
								} else {
									console.log('Mesh has no mediaUrl:', mesh.name);
								}
							}
						});

						editor.scene.add(sceneGroup);
						frameScene(editor, sceneGroup);
						// Reframe after first render tick to ensure bounds are final
						requestAnimationFrame(()=> frameScene(editor, sceneGroup));

						// Update the editor
						editor.signals.sceneGraphChanged.dispatch();
						editor.signals.objectSelected.dispatch(null);

						console.log(`Scene loaded successfully with ${sceneGroup.children.length} objects`);

						// Send success response
						send({
							type: 'scene_loaded',
							data: { success: true, objectCount: sceneGroup.children.length },
							commandId: command.id
						});

					} catch (error) {
						console.error('Simpler scene loading failed:', error);
						send({
							type: 'scene_loaded',
							data: { success: false, error: error.message },
							commandId: command.id
						});
					}
				} else {
					console.log('No scene data or children found, scene remains empty');
					// Send success response even for empty scene
					send({
						type: 'scene_loaded',
						data: { success: true, objectCount: 0 },
						commandId: command.id
					});
				}
				break;

				case 'clear_scene':
					editor.clear();
					console.log('Scene cleared');
					break;

				case 'add_object':
					try {
						const objData = command.data;
						let geometry, material;

						// Create geometry
						switch (objData.geometry.type) {
							case 'BoxGeometry':
								geometry = new THREE.BoxGeometry(
									objData.geometry.width || 1,
									objData.geometry.height || 1,
									objData.geometry.depth || 1
								);
								break;
							case 'SphereGeometry':
								geometry = new THREE.SphereGeometry(objData.geometry.radius || 0.5);
								break;
							case 'PlaneGeometry':
								geometry = new THREE.PlaneGeometry(
									objData.geometry.width || 1,
									objData.geometry.height || 1
								);
								break;
							default:
								geometry = new THREE.BoxGeometry(1, 1, 1);
						}

						// Neutral base color; texture/video will set to white
						material = new THREE.MeshBasicMaterial({ color: 0x999999, side: THREE.DoubleSide });

						// Create mesh
						const mesh = new THREE.Mesh(geometry, material);
						mesh.name = objData.name || 'Object';
						mesh.position.fromArray(objData.position || [0, 0, 0]);
						if (objData.rotation) mesh.rotation.fromArray(objData.rotation);
						if (objData.scale) mesh.scale.fromArray(objData.scale);
						mesh.userData = objData.userData || {};
						editor.addObject(mesh);

						// Apply media if provided (image/video), same as load path
						if (objData.userData && objData.userData.mediaUrl) {
							console.log('Loading media for add_object:', objData.userData.mediaUrl);
							applyMediaToMesh(mesh, objData.userData.mediaUrl, objData.userData.assetType, editor);
						}

						console.log('Added object:', mesh.name);
						// Send success response
						send({
							type: 'object_added_success',
							data: { success: true, uuid: mesh.uuid, name: mesh.name },
							commandId: command.id
						});
					} catch (error) {
						console.error('Failed to add object:', error);
						send({ type: 'error', data: { error: 'Failed to add object: ' + error.message } });
					}
					break;

				case 'export_scene':
					try {
						console.log('Exporting scene...');
						// Temporarily remove helper frames (ignoreSave) from the live scene, then restore
						const removed = [];
						editor.scene.traverse((obj) => {
							if (obj.userData && obj.userData.ignoreSave && obj.parent) {
								removed.push({ obj, parent: obj.parent });
							}
						});
						removed.forEach(({ obj, parent }) => { try { parent.remove(obj); } catch {} });
						const sceneJSON = editor.scene.toJSON();
						removed.forEach(({ obj, parent }) => { try { parent.add(obj); } catch {} });
						console.log('Scene JSON:', sceneJSON);
						send({
							type: 'scene_exported',
							data: sceneJSON,
							commandId: command.id
						});
						console.log('Scene exported successfully');
					} catch (error) {
						console.error('Failed to export scene:', error);
						send({ type: 'error', data: { error: 'Failed to export scene: ' + error.message } });
					}
					break;
			}
		});

			//

			document.addEventListener( 'dragover', function ( event ) {

				event.preventDefault();
				event.dataTransfer.dropEffect = 'copy';

			} );

			document.addEventListener( 'drop', function ( event ) {

				event.preventDefault();

				if ( event.dataTransfer.types[ 0 ] === 'text/plain' ) return; // Outliner drop

				if ( event.dataTransfer.items ) {

					// DataTransferItemList supports folders

					editor.loader.loadItemList( event.dataTransfer.items );

				} else {

					editor.loader.loadFiles( event.dataTransfer.files );

				}

			} );



						// Shared helper to apply image/video media to a mesh consistently
			function applyMediaToMesh(mesh, url, assetType, editor) {
				if (!url) return;
				const isVideo = (assetType === 'video') || /\.mp4(\?|$)/i.test(url);
				console.log('applyMediaToMesh:', mesh.name, 'url:', url, 'assetType:', assetType, 'isVideo:', isVideo);
				if (isVideo) {
					console.log('Creating video texture for:', mesh.name);

					// Create video element
					const video = document.createElement('video');
					video.src = url;
					video.crossOrigin = 'anonymous';
					video.muted = true;
					video.loop = true;
					video.playsInline = true;
					video.autoplay = false;
					video.style.display = 'none';
					document.body.appendChild(video);

					console.log('Video element created, src:', video.src);

					// Wait for video to be ready before creating texture
					video.addEventListener('loadeddata', () => {
						console.log('Video loaded data, ready state:', video.readyState);
							
							// Create VideoTexture only when video is ready
							const videoTexture = new THREE.VideoTexture(video);
							videoTexture.minFilter = THREE.LinearFilter;
							videoTexture.magFilter = THREE.LinearFilter;
							videoTexture.format = THREE.RGBAFormat;
							videoTexture.type = THREE.UnsignedByteType;
							videoTexture.colorSpace = THREE.SRGBColorSpace;
							videoTexture.generateMipmaps = false;
							videoTexture.wrapS = THREE.ClampToEdgeWrapping;
							videoTexture.wrapT = THREE.ClampToEdgeWrapping;
							videoTexture.flipY = false;
							
							console.log('VideoTexture created with ready video');
							
							// Apply to material
							const videoMaterial = new THREE.MeshBasicMaterial({ map: videoTexture, side: THREE.DoubleSide, toneMapped: false });
							mesh.material = videoMaterial;
							mesh.material.needsUpdate = true;
							
							console.log('Material applied to mesh');
							
							// Start video
							video.play().then(() => {
								console.log('Video playing successfully');
								videoTexture.needsUpdate = true;
								console.log('Forced initial texture update');
								// Force a render update to ensure video appears
								if (editor.signals && editor.signals.sceneGraphChanged) {
									editor.signals.sceneGraphChanged.dispatch();
								}
							}).catch(err => {
								console.log('Video autoplay failed, will play on user interaction:', err);
							});
							
							// Also nudge updates when player becomes ready
							const bumpUpdate = () => { try { videoTexture.needsUpdate = true; } catch {} };
							video.addEventListener('canplay', bumpUpdate, { once: true });
							video.addEventListener('loadedmetadata', bumpUpdate, { once: true });
							
							// Track video element
							videoMap.set(mesh.uuid, video);
							console.log('Video mapped for mesh:', mesh.uuid, 'mesh.name:', mesh.name);
							console.log('VideoMap now has:', Array.from(videoMap.keys()));
							
							// Notify editor
							if (editor.signals && editor.signals.materialChanged) {
								editor.signals.materialChanged.dispatch(mesh.material);
							}
							if (editor.signals && editor.signals.sceneGraphChanged) {
								editor.signals.sceneGraphChanged.dispatch();
							}
							ensureFrameForMesh(mesh, editor);
						});

					// Handle video load errors
					video.addEventListener('error', (e) => {
						console.error('Video load error:', e);
					});
				} else {
					console.log('Loading image texture for:', mesh.name, 'URL:', url);
					const textureLoader = new THREE.TextureLoader();
					textureLoader.crossOrigin = 'anonymous';
					textureLoader.load(
						url,
						(texture) => {
							console.log('Image texture loaded successfully for:', mesh.name);
							// Configure texture properties
							texture.colorSpace = THREE.SRGBColorSpace;
							texture.format = THREE.RGBAFormat;
							texture.type = THREE.UnsignedByteType;
							texture.generateMipmaps = false;
							texture.minFilter = THREE.LinearFilter;
							texture.magFilter = THREE.LinearFilter;
							texture.wrapS = THREE.ClampToEdgeWrapping;
							texture.wrapT = THREE.ClampToEdgeWrapping;
							texture.flipY = false;

							// Wait for image to be fully loaded before applying texture
							const applyTextureWhenReady = () => {
								if (texture.image && texture.image.complete && texture.image.naturalWidth > 0) {
									console.log('Image ready, applying texture to:', mesh.name);

									if (!mesh.material || !(mesh.material instanceof THREE.MeshBasicMaterial)) {
										mesh.material = new THREE.MeshBasicMaterial({ side: THREE.DoubleSide, toneMapped: false });
									}
									mesh.material.color && mesh.material.color.set(0xffffff);
									mesh.material.map = texture;
									mesh.material.needsUpdate = true;
									texture.needsUpdate = true;

									// Notify editor
									if (editor.signals && editor.signals.materialChanged) {
										editor.signals.materialChanged.dispatch(mesh.material);
									}
									if (editor.signals && editor.signals.sceneGraphChanged) {
										editor.signals.sceneGraphChanged.dispatch();
									}
									ensureFrameForMesh(mesh, editor);
								} else {
									console.log('Image not ready yet, waiting...', mesh.name);
									requestAnimationFrame(applyTextureWhenReady);
								}
							};

							applyTextureWhenReady();
						},
						undefined,
						(error) => {
							console.error('Error loading texture for mesh:', mesh.name, error);
							// Create a fallback material for failed textures
							if (!mesh.material || !(mesh.material instanceof THREE.MeshBasicMaterial)) {
								mesh.material = new THREE.MeshBasicMaterial({ 
									side: THREE.DoubleSide, 
									toneMapped: false,
									color: 0xff0000 // Red color to indicate error
								});
							}
						}
					);
				}
			}

			function onWindowResize() {

				editor.signals.windowResize.dispatch();

			}

			window.addEventListener( 'resize', onWindowResize );

			onWindowResize();

			//

			let isLoadingFromHash = false;
			const hash = window.location.hash;

			if ( hash.slice( 1, 6 ) === 'file=' ) {

				const file = hash.slice( 6 );

				if ( confirm( editor.strings.getKey( 'prompt/file/open' ) ) ) {

					const loader = new THREE.FileLoader();
					loader.crossOrigin = '';
					loader.load( file, function ( text ) {

						editor.clear();
						editor.fromJSON( JSON.parse( text ) );

					} );

					isLoadingFromHash = true;

				}

			}

			// ServiceWorker

			if ( 'serviceWorker' in navigator ) {

				try {

					navigator.serviceWorker.register( 'sw.js' );

				} catch ( error ) {

				}

			}

		</script>
	</body>
</html>

// Redeploy marker: loader unchanged; textures only
